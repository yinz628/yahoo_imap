<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Yahoo Mail Extractor</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f5f5f5; min-height: 100vh; }
    
    /* Login Page Styles */
    .login-container {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .login-card {
      background: white;
      border-radius: 12px;
      padding: 40px;
      width: 100%;
      max-width: 400px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    }
    
    /* Mobile: Smaller login card padding */
    @media (max-width: 768px) {
      .login-card {
        padding: 30px 20px;
      }
      .login-card h1 {
        font-size: 24px;
      }
    }
    .login-card h1 {
      color: #6001d2;
      text-align: center;
      margin-bottom: 10px;
      font-size: 28px;
    }
    .login-card .subtitle {
      color: #666;
      text-align: center;
      margin-bottom: 30px;
      font-size: 14px;
    }
    .login-card .form-group {
      margin-bottom: 20px;
    }
    .login-card label {
      display: block;
      margin-bottom: 8px;
      color: #333;
      font-weight: 500;
    }
    .login-card input {
      width: 100%;
      padding: 12px 15px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 15px;
      transition: border-color 0.2s;
    }
    .login-card input:focus {
      outline: none;
      border-color: #6001d2;
    }
    .login-card button {
      width: 100%;
      background: #6001d2;
      color: white;
      border: none;
      padding: 14px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }
    .login-card button:hover {
      background: #4a01a3;
    }
    .login-card button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .login-toggle {
      text-align: center;
      margin-top: 20px;
      color: #666;
      font-size: 14px;
    }
    .login-toggle a {
      color: #6001d2;
      text-decoration: none;
      font-weight: 500;
      cursor: pointer;
    }
    .login-toggle a:hover {
      text-decoration: underline;
    }
    .login-error {
      background: #f8d7da;
      color: #721c24;
      padding: 12px 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      font-size: 14px;
      display: none;
    }
    .login-error.visible {
      display: block;
    }
    .login-success {
      background: #d4edda;
      color: #155724;
      padding: 12px 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      font-size: 14px;
      display: none;
    }
    .login-success.visible {
      display: block;
    }

    /* Main App Styles */
    .app-container {
      display: none;
      padding: 20px;
    }
    .app-container.visible {
      display: block;
    }
    .container { max-width: 1200px; margin: 0 auto; width: 100%; }
    
    /* Responsive adjustments */
    @media (max-width: 1024px) {
      .container { max-width: 100%; }
    }
    h1 { color: #6001d2; margin-bottom: 20px; text-align: center; }
    .card { background: white; border-radius: 8px; padding: 20px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    
    /* Mobile: Reduce card padding */
    @media (max-width: 768px) {
      .card { padding: 15px; margin-bottom: 15px; }
    }
    .card h2 { color: #333; margin-bottom: 15px; font-size: 18px; border-bottom: 2px solid #6001d2; padding-bottom: 8px; }
    .form-group { margin-bottom: 15px; }
    label { display: block; margin-bottom: 5px; color: #555; font-weight: 500; }
    input, select, textarea { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; }
    input:focus, select:focus, textarea:focus { outline: none; border-color: #6001d2; }
    
    /* Settings checkbox style */
    .settings-checkbox { display: flex; align-items: center; gap: 10px; margin-bottom: 12px; cursor: pointer; }
    .settings-checkbox input[type="checkbox"] { width: 18px; height: 18px; flex-shrink: 0; cursor: pointer; }
    .settings-checkbox span { font-size: 14px; color: #333; }
    
    .row { display: flex; gap: 15px; }
    .row .form-group { flex: 1; }
    
    /* Mobile: Stack rows vertically */
    @media (max-width: 768px) {
      .row { flex-direction: column; gap: 10px; }
    }
    button { background: #6001d2; color: white; border: none; padding: 12px 24px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 500; }
    button:hover { background: #4a01a3; }
    button:disabled { background: #ccc; cursor: not-allowed; }
    
    /* Mobile: Smaller buttons */
    @media (max-width: 768px) {
      button { padding: 10px 16px; font-size: 13px; }
    }
    .btn-secondary { background: #666; }
    .btn-secondary:hover { background: #555; }
    .btn-danger { background: #dc3545; }
    .btn-danger:hover { background: #c82333; }
    .status { padding: 10px; border-radius: 4px; margin-bottom: 15px; }
    .status.success { background: #d4edda; color: #155724; }
    .status.error { background: #f8d7da; color: #721c24; }
    .status.info { background: #cce5ff; color: #004085; }
    .hidden { display: none; }
    #results { max-height: 400px; overflow-y: auto; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    th, td { padding: 8px; text-align: left; border-bottom: 1px solid #eee; }
    th { background: #f8f9fa; font-weight: 600; position: sticky; top: 0; }
    tr:hover { background: #f8f9fa; }
    
    /* Mobile: Smaller table text and padding */
    @media (max-width: 768px) {
      table { font-size: 11px; }
      th, td { padding: 6px 4px; }
      
      /* Hide less important columns on mobile */
      .email-sender {
        display: none;
      }
      th:nth-child(3),
      td:nth-child(3) {
        display: none;
      }
    }
    .match { background: #fff3cd; padding: 2px 4px; border-radius: 2px; }
    .progress { height: 20px; background: #e9ecef; border-radius: 4px; overflow: hidden; margin: 10px 0; }
    .progress-bar { height: 100%; background: #6001d2; transition: width 0.3s; }
    .checkbox-group { display: flex; align-items: center; gap: 8px; }
    .checkbox-group input { width: auto; }

    /* Navigation Sidebar */
    .app-layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 200px;
      background: white;
      border-right: 1px solid #e0e0e0;
      display: flex;
      flex-direction: column;
      position: fixed;
      left: 0;
      top: 0;
      bottom: 0;
      z-index: 100;
      box-shadow: 2px 0 8px rgba(0,0,0,0.05);
      transition: transform 0.3s ease;
    }
    
    /* Mobile: Hide sidebar by default, show with toggle */
    @media (max-width: 768px) {
      .sidebar {
        transform: translateX(-100%);
      }
      .sidebar.mobile-open {
        transform: translateX(0);
      }
    }
    .sidebar-header {
      padding: 20px 15px;
      border-bottom: 1px solid #e0e0e0;
      text-align: center;
      position: relative;
    }
    .sidebar-header h1 {
      font-size: 18px;
      color: #6001d2;
      margin: 0;
    }
    
    /* Mobile close button in sidebar */
    .sidebar-close-btn {
      display: none;
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      font-size: 24px;
      color: #666;
      cursor: pointer;
      padding: 5px;
      line-height: 1;
    }
    
    @media (max-width: 768px) {
      .sidebar-close-btn {
        display: block;
      }
    }
    .sidebar-nav {
      flex: 1;
      padding: 15px 0;
    }
    .nav-item {
      display: flex;
      align-items: center;
      padding: 12px 20px;
      color: #555;
      cursor: pointer;
      transition: all 0.2s;
      border-left: 3px solid transparent;
      font-size: 14px;
    }
    .nav-item:hover {
      background: #f5f5f5;
      color: #6001d2;
    }
    .nav-item.active {
      background: #f0e6ff;
      color: #6001d2;
      border-left-color: #6001d2;
      font-weight: 500;
    }
    .nav-item .nav-icon {
      margin-right: 10px;
      font-size: 16px;
    }
    .sidebar-footer {
      padding: 15px;
      border-top: 1px solid #e0e0e0;
      background: #fafafa;
    }
    .sidebar-user {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
      font-size: 13px;
      color: #333;
    }
    .sidebar-user .user-icon {
      margin-right: 8px;
      font-size: 16px;
    }
    .sidebar-user .username {
      color: #6001d2;
      font-weight: 500;
    }
    .sidebar-logout {
      width: 100%;
      background: #dc3545;
      color: white;
      border: none;
      padding: 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      transition: background 0.2s;
    }
    .sidebar-logout:hover {
      background: #c82333;
    }
    
    /* Main Content Area */
    .main-content {
      flex: 1;
      margin-left: 200px;
      padding: 20px;
      min-height: 100vh;
      max-width: 100%;
      overflow-x: hidden;
    }
    
    /* Mobile: No left margin, add menu button */
    @media (max-width: 768px) {
      .main-content {
        margin-left: 0;
        padding: 10px;
      }
    }
    
    /* Feature Modules */
    .feature-module {
      display: none;
    }
    .feature-module.active {
      display: block;
    }
    
    /* Legacy User Header - hidden when sidebar is used */
    .user-header {
      display: none;
    }
    
    /* Mailbox List Styles */
    .mailbox-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 15px;
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      margin-bottom: 10px;
      transition: all 0.2s;
    }
    .mailbox-item:hover {
      border-color: #6001d2;
      box-shadow: 0 2px 8px rgba(96, 1, 210, 0.1);
    }
    .mailbox-item .mailbox-info {
      display: flex;
      align-items: center;
      gap: 10px;
      flex: 1;
      cursor: pointer;
    }
    .mailbox-item .mailbox-icon {
      font-size: 20px;
    }
    .mailbox-item .mailbox-email {
      font-weight: 500;
      color: #333;
    }
    .mailbox-item .mailbox-date {
      font-size: 12px;
      color: #999;
    }
    .mailbox-item .mailbox-actions {
      display: flex;
      gap: 8px;
    }
    .mailbox-item .btn-use {
      background: #6001d2;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    .mailbox-item .btn-use:hover {
      background: #4a01a3;
    }
    .mailbox-item .btn-delete {
      background: #dc3545;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    .mailbox-item .btn-delete:hover {
      background: #c82333;
    }
    .mailbox-empty {
      text-align: center;
      padding: 30px;
      color: #999;
      background: #f9f9f9;
      border-radius: 6px;
      border: 1px dashed #ddd;
    }
    
    /* Pattern History Styles */
    .pattern-item {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      padding: 12px 15px;
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      margin-bottom: 10px;
      transition: all 0.2s;
    }
    .pattern-item:hover {
      border-color: #6001d2;
      box-shadow: 0 2px 8px rgba(96, 1, 210, 0.1);
    }
    .pattern-item .pattern-info {
      flex: 1;
      cursor: pointer;
      min-width: 0;
    }
    .pattern-item .pattern-subject {
      font-weight: 500;
      color: #333;
      margin-bottom: 4px;
      word-break: break-word;
    }
    .pattern-item .pattern-regex {
      font-family: monospace;
      font-size: 12px;
      color: #666;
      background: #f5f5f5;
      padding: 4px 8px;
      border-radius: 3px;
      word-break: break-all;
      display: block;
      margin-bottom: 4px;
    }
    .pattern-item .pattern-date {
      font-size: 11px;
      color: #999;
    }
    .pattern-item .pattern-actions {
      display: flex;
      gap: 8px;
      margin-left: 10px;
      flex-shrink: 0;
    }
    .pattern-item .btn-apply {
      background: #6001d2;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    .pattern-item .btn-apply:hover {
      background: #4a01a3;
    }
    .pattern-item .btn-delete-pattern {
      background: #dc3545;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    .pattern-item .btn-delete-pattern:hover {
      background: #c82333;
    }
    
    /* Rule History Styles */
    .rule-item {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      padding: 12px 15px;
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      margin-bottom: 10px;
      transition: all 0.2s;
    }
    .rule-item:hover {
      border-color: #6001d2;
      box-shadow: 0 2px 8px rgba(96, 1, 210, 0.1);
    }
    .rule-item .rule-info {
      flex: 1;
      cursor: pointer;
      min-width: 0;
    }
    .rule-item .rule-name {
      font-weight: 600;
      color: #6001d2;
      margin-bottom: 4px;
      font-size: 14px;
    }
    .rule-item .rule-subject {
      font-size: 13px;
      color: #333;
      margin-bottom: 4px;
      word-break: break-word;
    }
    .rule-item .rule-regex {
      font-family: monospace;
      font-size: 11px;
      color: #666;
      background: #f5f5f5;
      padding: 4px 8px;
      border-radius: 3px;
      word-break: break-all;
      display: block;
      margin-bottom: 4px;
    }
    .rule-item .rule-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-bottom: 4px;
    }
    .rule-item .rule-tag {
      display: inline-block;
      background: #e3f2fd;
      color: #1565c0;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 11px;
      cursor: pointer;
    }
    .rule-item .rule-tag:hover {
      background: #bbdefb;
    }
    .rule-item .rule-meta {
      font-size: 11px;
      color: #999;
    }
    .rule-item .rule-actions {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-left: 10px;
      flex-shrink: 0;
    }
    .rule-item .btn-use-rule {
      background: #6001d2;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      white-space: nowrap;
    }
    .rule-item .btn-use-rule:hover {
      background: #4a01a3;
    }
    .rule-item .btn-edit-rule {
      background: #17a2b8;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      white-space: nowrap;
    }
    .rule-item .btn-edit-rule:hover {
      background: #138496;
    }
    .rule-item .btn-delete-rule {
      background: #dc3545;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      white-space: nowrap;
    }
    .rule-item .btn-delete-rule:hover {
      background: #c82333;
    }
    .rule-empty {
      text-align: center;
      padding: 30px;
      color: #999;
      background: #f9f9f9;
      border-radius: 6px;
      border: 1px dashed #ddd;
    }
    .pattern-empty {
      text-align: center;
      padding: 20px;
      color: #999;
      background: #f9f9f9;
      border-radius: 6px;
      border: 1px dashed #ddd;
      font-size: 13px;
    }
    
    /* Pattern Tags Styles */
    .pattern-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 4px;
    }
    .pattern-tag {
      display: inline-block;
      background: #e3f2fd;
      color: #1565c0;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 11px;
      cursor: pointer;
    }
    .pattern-tag:hover {
      background: #bbdefb;
    }
    
    /* Email Management Styles */
    .folder-item {
      padding: 10px 12px;
      cursor: pointer;
      border-radius: 4px;
      margin-bottom: 4px;
      font-size: 13px;
      color: #555;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .folder-item:hover {
      background: #f0f0f0;
      color: #6001d2;
    }
    .folder-item.active {
      background: #f0e6ff;
      color: #6001d2;
      font-weight: 500;
    }
    .folder-item .folder-icon {
      font-size: 14px;
    }
    .folder-item .folder-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .email-row {
      cursor: pointer;
      transition: background 0.2s;
    }
    .email-row:hover {
      background: #f5f5f5;
    }
    .email-row.selected {
      background: #f0e6ff;
    }
    .email-checkbox {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }
    .email-subject {
      max-width: 300px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .email-sender {
      max-width: 150px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .email-date {
      font-size: 12px;
      color: #666;
      white-space: nowrap;
    }
    .pagination-btn {
      padding: 6px 12px;
      font-size: 13px;
    }
    .pagination-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* Email Content Modal */
    .email-modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    .email-modal-overlay.visible {
      display: flex;
    }
    .email-modal {
      background: white;
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    }
    .email-modal-header {
      padding: 20px;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }
    .email-modal-header h3 {
      margin: 0;
      color: #333;
      font-size: 18px;
      word-break: break-word;
      flex: 1;
      padding-right: 15px;
    }
    .email-modal-close {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #666;
      padding: 0;
      line-height: 1;
    }
    .email-modal-close:hover {
      color: #333;
    }
    .email-modal-meta {
      padding: 15px 20px;
      background: #f9f9f9;
      border-bottom: 1px solid #e0e0e0;
      font-size: 13px;
      color: #666;
    }
    .email-modal-meta p {
      margin: 5px 0;
    }
    .email-modal-meta strong {
      color: #333;
    }
    .email-modal-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
      font-size: 14px;
      line-height: 1.6;
    }
    .email-modal-body pre {
      white-space: pre-wrap;
      word-wrap: break-word;
      font-family: inherit;
      margin: 0;
    }
    .email-modal-loading {
      text-align: center;
      padding: 40px;
      color: #666;
    }
    
    /* Code Pattern Builder Modal */
    .pattern-builder-modal {
      background: white;
      border-radius: 12px;
      width: 95%;
      max-width: 700px;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    }
    .pattern-builder-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
    }
    .pattern-part {
      background: #f8f9fa;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
    }
    .pattern-part-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .pattern-part-header label {
      font-weight: 600;
      color: #333;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .pattern-part-header .part-badge {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 10px;
      background: #6001d2;
      color: white;
    }
    .pattern-part-toggle {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .pattern-part-toggle input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }
    .pattern-part-content {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .pattern-part-content input,
    .pattern-part-content select {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    .pattern-part-content input:focus,
    .pattern-part-content select:focus {
      outline: none;
      border-color: #6001d2;
    }
    .pattern-part-hint {
      font-size: 12px;
      color: #666;
      margin-top: 5px;
    }
    .pattern-preview-box {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 15px;
      border-radius: 8px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 14px;
      word-break: break-all;
      margin-top: 15px;
    }
    .pattern-preview-box .regex-prefix { color: #9cdcfe; }
    .pattern-preview-box .regex-fixed { color: #ce9178; }
    .pattern-preview-box .regex-variable { color: #4ec9b0; }
    .pattern-preview-box .regex-separator { color: #d7ba7d; }
    .pattern-preview-box .regex-group { color: #dcdcaa; }
    .pattern-builder-actions {
      padding: 15px 20px;
      border-top: 1px solid #e0e0e0;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    .pattern-builder-actions button {
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
    }
    .quick-prefix-btns {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 8px;
    }
    /* Code segment styles */
    .code-segment {
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 10px;
    }
    .code-segment-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .code-segment-header .segment-label {
      font-weight: 600;
      color: #333;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .code-segment-header .segment-value {
      font-family: 'Consolas', 'Monaco', monospace;
      background: #f0f0f0;
      padding: 2px 8px;
      border-radius: 4px;
      color: #6001d2;
    }
    .code-segment-body {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }
    .segment-type-select {
      padding: 6px 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 13px;
      min-width: 120px;
    }
    .segment-type-select:focus {
      outline: none;
      border-color: #6001d2;
    }
    .segment-length-info {
      font-size: 12px;
      color: #666;
      background: #f8f9fa;
      padding: 4px 8px;
      border-radius: 4px;
    }
    .segment-fixed-badge {
      background: #ce9178;
      color: white;
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 11px;
    }
    .segment-variable-badge {
      background: #4ec9b0;
      color: white;
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 11px;
    }
    .segment-separator {
      text-align: center;
      color: #d7ba7d;
      font-weight: bold;
      font-size: 18px;
      padding: 5px 0;
    }

    .quick-prefix-btn {
      padding: 4px 10px;
      font-size: 12px;
      background: #e9ecef;
      border: 1px solid #ced4da;
      border-radius: 4px;
      cursor: pointer;
    }
    .quick-prefix-btn:hover {
      background: #dee2e6;
    }
    .quick-prefix-btn.active {
      background: #6001d2;
      color: white;
      border-color: #6001d2;
    }
    .separator-options {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .separator-option {
      display: flex;
      align-items: center;
      gap: 5px;
      cursor: pointer;
    }
    .separator-option input[type="radio"] {
      cursor: pointer;
    }
    .analyzed-parts {
      background: #fff3cd;
      border: 1px solid #ffc107;
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 15px;
    }
    .analyzed-parts-title {
      font-weight: 600;
      color: #856404;
      margin-bottom: 8px;
    }
    .analyzed-parts-content {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .analyzed-part-tag {
      background: white;
      border: 1px solid #ffc107;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 13px;
    }
    .analyzed-part-tag.prefix { border-color: #9cdcfe; background: #e8f4fd; }
    .analyzed-part-tag.fixed { border-color: #ce9178; background: #fdf2e8; }
    .analyzed-part-tag.variable { border-color: #4ec9b0; background: #e8fdf8; }
    .analyzed-part-tag.separator { border-color: #d7ba7d; background: #fdfbe8; }
    
    /* Email Preview Search Styles */
    /* Requirements: 2.3, 2.4 */
    .preview-search-box {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px;
      background: #f0f0f0;
      border-radius: 4px 4px 0 0;
      border: 1px solid #ddd;
      border-bottom: none;
    }
    .preview-search-box input {
      flex: 1;
      padding: 6px 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 13px;
      min-width: 150px;
    }
    .preview-search-box input:focus {
      outline: none;
      border-color: #6001d2;
    }
    .preview-search-box .search-nav-btn {
      background: #6001d2;
      color: white;
      border: none;
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      min-width: 32px;
    }
    .preview-search-box .search-nav-btn:hover {
      background: #4a01a3;
    }
    .preview-search-box .search-nav-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .preview-search-box .search-count {
      font-size: 12px;
      color: #666;
      white-space: nowrap;
      min-width: 60px;
      text-align: center;
    }
    .preview-search-box .search-clear-btn {
      background: #dc3545;
      color: white;
      border: none;
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    .preview-search-box .search-clear-btn:hover {
      background: #c82333;
    }
    .search-highlight {
      background: #fff3cd;
      padding: 1px 2px;
      border-radius: 2px;
      border: 1px solid #ffc107;
    }
    .search-highlight.current {
      background: #ffc107;
      border-color: #e0a800;
      box-shadow: 0 0 4px rgba(255, 193, 7, 0.5);
    }
    .preview-content-wrapper {
      margin-top: 0;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 0 0 4px 4px;
      max-height: 450px;
      overflow: auto;
      white-space: pre-wrap;
      font-family: monospace;
      font-size: 12px;
      border: 1px solid #ddd;
      border-top: none;
    }
    .preview-content-wrapper.no-search {
      border-radius: 4px;
      border-top: 1px solid #ddd;
    }
    .preview-generate-rule-btn {
      background: #28a745;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      margin-left: 8px;
    }
    .preview-generate-rule-btn:hover {
      background: #218838;
    }
    .preview-generate-rule-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    /* Rule Editor Panel Styles - Requirements: 3.4, 4.1, 4.6 */
    #ruleEditorCard {
      transition: box-shadow 0.2s;
    }
    #ruleEditorCard:focus-within {
      box-shadow: 0 4px 12px rgba(96, 1, 210, 0.2);
    }
    #ruleEditorCard h2 {
      color: #6001d2;
      border-bottom-color: #6001d2;
    }
    #ruleEditorCard .form-group label {
      font-size: 13px;
    }
    #ruleEditorCard input:focus,
    #ruleEditorCard select:focus {
      border-color: #6001d2;
      box-shadow: 0 0 0 2px rgba(96, 1, 210, 0.1);
    }
    .rule-validation-success {
      background: #d4edda;
      color: #155724;
      padding: 10px;
      border-radius: 4px;
      border: 1px solid #c3e6cb;
    }
    .rule-validation-error {
      background: #f8d7da;
      color: #721c24;
      padding: 10px;
      border-radius: 4px;
      border: 1px solid #f5c6cb;
    }
    .rule-validation-warning {
      background: #fff3cd;
      color: #856404;
      padding: 10px;
      border-radius: 4px;
      border: 1px solid #ffeaa7;
    }
    .rule-match-highlight {
      background: #fff3cd;
      padding: 2px 4px;
      border-radius: 2px;
      border: 1px solid #ffc107;
      font-weight: 500;
    }
    .pattern-suggestion-item {
      padding: 10px;
      margin: 8px 0;
      background: white;
      border-radius: 4px;
      border-left: 3px solid #6001d2;
      cursor: pointer;
      transition: all 0.2s;
    }
    .pattern-suggestion-item:hover {
      background: #f8f9fa;
      border-left-color: #28a745;
    }
    .pattern-suggestion-item .pattern-name {
      font-weight: 600;
      color: #6001d2;
      margin-bottom: 4px;
    }
    .pattern-suggestion-item .pattern-code {
      font-family: monospace;
      font-size: 12px;
      color: #666;
      background: #f5f5f5;
      padding: 4px 8px;
      border-radius: 3px;
      display: block;
      margin-bottom: 4px;
    }
    .pattern-suggestion-item .pattern-desc {
      font-size: 12px;
      color: #999;
    }
    
    /* Mobile Menu Button */
    .mobile-menu-btn {
      display: none;
      position: fixed;
      top: 15px;
      left: 15px;
      z-index: 101;
      background: #6001d2;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 18px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    
    @media (max-width: 768px) {
      .mobile-menu-btn {
        display: block;
      }
    }
    
    /* Mobile Overlay */
    .mobile-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 99;
    }
    
    @media (max-width: 768px) {
      .mobile-overlay.visible {
        display: block;
      }
    }
    
    /* Responsive Email Modal */
    @media (max-width: 768px) {
      .email-modal {
        width: 95%;
        max-height: 95vh;
      }
      .email-modal-header h3 {
        font-size: 16px;
      }
      .email-modal-body {
        font-size: 13px;
      }
    }
    
    /* Responsive Preview Search Box */
    @media (max-width: 768px) {
      .preview-search-box {
        flex-wrap: wrap;
        gap: 6px;
      }
      .preview-search-box input {
        min-width: 100px;
        flex: 1 1 100%;
      }
      .preview-search-box .search-count {
        min-width: 50px;
      }
    }
    
    /* Responsive Email Management Layout */
    @media (max-width: 1024px) {
      #module-email-management > div > div {
        flex-direction: column !important;
      }
      #module-email-management .card[style*="width:200px"] {
        width: 100% !important;
      }
    }
    
    /* Responsive button groups */
    @media (max-width: 768px) {
      div[style*="display:flex"][style*="gap"] {
        flex-wrap: wrap;
      }
      .mailbox-item {
        flex-direction: column;
        align-items: flex-start;
      }
      .mailbox-item .mailbox-actions {
        width: 100%;
        margin-top: 10px;
      }
      .pattern-item,
      .rule-item {
        flex-direction: column;
        align-items: flex-start;
      }
      .pattern-item .pattern-actions,
      .rule-item .rule-actions {
        width: 100%;
        margin-left: 0;
        margin-top: 10px;
        flex-direction: row;
      }
    }
    
    /* Responsive form groups */
    @media (max-width: 768px) {
      .form-group label {
        font-size: 13px;
      }
      input, select, textarea {
        font-size: 14px;
        padding: 8px;
      }
    }
    
    /* Responsive headings */
    @media (max-width: 768px) {
      h1 {
        font-size: 24px;
        margin-bottom: 15px;
      }
      .card h2 {
        font-size: 16px;
      }
    }
    
    /* Ensure content doesn't overflow */
    * {
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    /* Responsive pagination */
    @media (max-width: 768px) {
      #emailPagination {
        flex-direction: column;
        gap: 10px;
        align-items: stretch;
      }
      #emailPagination > div {
        justify-content: center;
      }
    }
    
    /* Responsive status messages */
    @media (max-width: 768px) {
      .status {
        font-size: 13px;
        padding: 8px;
      }
    }
    
    /* Smooth scrolling */
    html {
      scroll-behavior: smooth;
    }
    
    /* Conversation View Styles */
    .conversation-item {
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      margin-bottom: 10px;
      overflow: hidden;
      transition: all 0.2s;
    }
    .conversation-item:hover {
      border-color: #6001d2;
      box-shadow: 0 2px 8px rgba(96, 1, 210, 0.1);
    }
    .conversation-item.expanded {
      border-color: #6001d2;
    }
    .conversation-header {
      display: flex;
      align-items: center;
      padding: 12px 15px;
      cursor: pointer;
      gap: 12px;
    }
    .conversation-header:hover {
      background: #f8f9fa;
    }
    .conversation-checkbox {
      flex-shrink: 0;
      width: 18px;
      height: 18px;
    }
    .conversation-expand-icon {
      flex-shrink: 0;
      font-size: 12px;
      color: #666;
      transition: transform 0.2s;
      width: 16px;
    }
    .conversation-item.expanded .conversation-expand-icon {
      transform: rotate(90deg);
    }
    .conversation-info {
      flex: 1;
      min-width: 0;
      overflow: hidden;
    }
    .conversation-subject {
      font-weight: 500;
      color: #333;
      margin-bottom: 4px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .conversation-meta {
      display: flex;
      gap: 15px;
      font-size: 12px;
      color: #666;
    }
    .conversation-count {
      background: #6001d2;
      color: white;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 500;
    }
    .conversation-participants {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 200px;
    }
    .conversation-date {
      flex-shrink: 0;
      font-size: 12px;
      color: #666;
    }
    .conversation-emails {
      display: none;
      border-top: 1px solid #e0e0e0;
      background: #f9f9f9;
    }
    .conversation-item.expanded .conversation-emails {
      display: block;
    }
    .conversation-email-item {
      display: flex;
      align-items: center;
      padding: 10px 15px 10px 45px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
      gap: 10px;
    }
    .conversation-email-item:last-child {
      border-bottom: none;
    }
    .conversation-email-item:hover {
      background: #f0e6ff;
    }
    .conversation-email-item.first-email {
      background: #fff9e6;
    }
    .conversation-email-checkbox {
      flex-shrink: 0;
      width: 18px;
      height: 18px;
    }
    .conversation-email-info {
      flex: 1;
      min-width: 0;
      overflow: hidden;
    }
    .conversation-email-subject {
      font-size: 13px;
      color: #333;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-bottom: 2px;
    }
    .conversation-email-sender {
      font-size: 12px;
      color: #666;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .conversation-email-date {
      flex-shrink: 0;
      font-size: 11px;
      color: #999;
      white-space: nowrap;
    }
    .conversation-empty {
      text-align: center;
      padding: 30px;
      color: #666;
    }
    
    /* View mode toggle button styles */
    #btnListView.active, #btnConversationView.active {
      background: #6001d2;
      color: white;
    }
    #btnListView:not(.active), #btnConversationView:not(.active) {
      background: #f0f0f0;
      color: #333;
    }
    #btnListView:not(.active):hover, #btnConversationView:not(.active):hover {
      background: #e0e0e0;
    }
  </style>
</head>
<body>
  <!-- Login Page -->
  <div class="login-container" id="loginPage">
    <div class="login-card">
      <h1>ğŸ“§ Yahoo Mail Extractor</h1>
      <p class="subtitle" id="loginSubtitle">è¯·ç™»å½•ä»¥è®¿é—®ç³»ç»Ÿ</p>
      
      <div class="login-error" id="loginError"></div>
      <div class="login-success" id="loginSuccess"></div>
      
      <form id="loginForm" onsubmit="handleAuthSubmit(event)">
        <div class="form-group">
          <label for="authUsername">ç”¨æˆ·å</label>
          <input type="text" id="authUsername" placeholder="è¯·è¾“å…¥ç”¨æˆ·å" required minlength="3" maxlength="20">
        </div>
        <div class="form-group">
          <label for="authPassword">å¯†ç </label>
          <input type="password" id="authPassword" placeholder="è¯·è¾“å…¥å¯†ç " required minlength="6">
        </div>
        <button type="submit" id="authSubmitBtn">ç™»å½•</button>
      </form>
    </div>
  </div>

  <!-- Main App (hidden until authenticated) -->
  <div class="app-container" id="mainApp">
    <!-- Mobile Menu Button -->
    <button class="mobile-menu-btn" id="mobileMenuBtn" onclick="toggleMobileMenu()">â˜°</button>
    
    <!-- Mobile Overlay -->
    <div class="mobile-overlay" id="mobileOverlay" onclick="closeMobileMenu()"></div>
    
    <div class="app-layout">
      <!-- Navigation Sidebar -->
      <nav class="sidebar" id="sidebar">
        <div class="sidebar-header">
          <h1>ğŸ“§ Yahoo Mail Extractor</h1>
          <button class="sidebar-close-btn" onclick="closeMobileMenu()">&times;</button>
        </div>
        <div class="sidebar-nav">
          <div class="nav-item active" data-module="mailbox-management" onclick="switchModule('mailbox-management')">
            <span class="nav-icon">ğŸ“¬</span>
            <span>é‚®ç®±ç®¡ç†</span>
          </div>
          <div class="nav-item" data-module="extraction" onclick="switchModule('extraction')">
            <span class="nav-icon">ğŸ«</span>
            <span>æå–æŠ˜æ‰£ç </span>
          </div>
          <div class="nav-item" data-module="email-management" onclick="switchModule('email-management')">
            <span class="nav-icon">ğŸ“§</span>
            <span>é‚®ä»¶ç®¡ç†</span>
          </div>
          <div class="nav-item" data-module="settings" onclick="switchModule('settings')">
            <span class="nav-icon">âš™ï¸</span>
            <span>æ•°æ®ç®¡ç†</span>
          </div>
        </div>
        <div class="sidebar-footer">
          <div class="sidebar-user">
            <span class="user-icon">ğŸ‘¤</span>
            <span>å½“å‰ç”¨æˆ·: <span class="username" id="sidebarUsername"></span></span>
          </div>
          <button class="sidebar-logout" onclick="handleLogout()">é€€å‡ºç™»å½•</button>
        </div>
      </nav>

      <!-- Main Content Area -->
      <main class="main-content">
        <!-- Debug Info (shown in all modules) -->
        <div class="card" style="background:#f0f0f0; margin-bottom:20px;">
          <h2 style="font-size:14px; color:#666;">ğŸ”§ è°ƒè¯•ä¿¡æ¯</h2>
          <p style="font-size:12px; color:#666; margin:0;">
            API åœ°å€: <code id="apiUrl"></code><br>
            æœåŠ¡å™¨çŠ¶æ€: <span id="serverStatus">æ£€æŸ¥ä¸­...</span>
          </p>
        </div>
        <script>document.getElementById('apiUrl').textContent = window.location.origin;</script>

        <!-- Module 1: Mailbox Management -->
        <div class="feature-module active" id="module-mailbox-management">
          <h1 style="color:#6001d2; margin-bottom:20px;">ğŸ“¬ é‚®ç®±ç®¡ç†</h1>
          
          <!-- Saved Mailboxes Card -->
          <div class="card" id="savedMailboxesCard">
            <h2>å·²ä¿å­˜çš„é‚®ç®±</h2>
            <div id="mailboxListStatus"></div>
            <div id="mailboxList" style="margin-bottom:15px;">
              <p style="color:#666;">åŠ è½½ä¸­...</p>
            </div>
            
            <!-- Add Mailbox Form -->
            <div style="background:#f9f9f9; padding:15px; border-radius:4px; margin-top:15px; border:1px solid #e0e0e0;">
              <h3 style="color:#333; margin-bottom:10px; font-size:16px;" id="mailboxFormTitle">â• æ·»åŠ æ–°é‚®ç®±</h3>
              <div class="row">
                <div class="form-group">
                  <label>é‚®ç®±ç±»å‹</label>
                  <select id="newMailboxProvider" onchange="updateMailboxPlaceholder()">
                    <option value="yahoo">Yahoo Mail</option>
                    <option value="gmail">Gmail</option>
                  </select>
                </div>
                <div class="form-group">
                  <label>é‚®ç®±åœ°å€</label>
                  <input type="email" id="newMailboxEmail" placeholder="your@yahoo.com">
                </div>
              </div>
              <div class="form-group">
                <label>App Password (åº”ç”¨ä¸“ç”¨å¯†ç )</label>
                <input type="password" id="newMailboxPassword" placeholder="xxxx xxxx xxxx xxxx">
                <small style="color:#666;" id="passwordHint">Yahoo: åœ¨è´¦æˆ·å®‰å…¨è®¾ç½®ä¸­ç”Ÿæˆåº”ç”¨ä¸“ç”¨å¯†ç </small>
              </div>
              <div style="display:flex; gap:10px;">
                <button onclick="saveMailboxForm()" id="saveMailboxBtn">æ·»åŠ é‚®ç®±</button>
                <button onclick="cancelMailboxEdit()" id="cancelMailboxBtn" class="btn-secondary" style="display:none;">å–æ¶ˆ</button>
              </div>
              <input type="hidden" id="editingMailboxId" value="">
            </div>
          </div>
          
          <!-- Connection Card -->
          <div class="card" id="connectionCard">
            <h2>è¿æ¥é‚®ç®±</h2>
            <div id="connectionStatus"></div>
            <div id="connectionForm">
              <div class="row">
                <div class="form-group">
                  <label>Yahoo é‚®ç®±åœ°å€</label>
                  <input type="email" id="email" placeholder="your@yahoo.com">
                </div>
                <div class="form-group">
                  <label>App Password (åº”ç”¨ä¸“ç”¨å¯†ç )</label>
                  <input type="password" id="password" placeholder="xxxx xxxx xxxx xxxx">
                </div>
              </div>
              <button onclick="connect()">è¿æ¥</button>
              <button class="btn-secondary" onclick="loadSettings()" style="margin-left:10px">åŠ è½½ä¿å­˜çš„é…ç½®</button>
            </div>
            <div id="connectedInfo" class="hidden">
              <p>âœ… å·²è¿æ¥: <strong id="connectedEmail"></strong></p>
              <div style="display:flex; gap:10px; margin-top:10px;">
                <button class="btn-secondary" onclick="saveSettings()">ğŸ’¾ ä¿å­˜é…ç½®</button>
                <button class="btn-danger" onclick="disconnect()">ğŸ”Œ æ–­å¼€è¿æ¥</button>
              </div>
            </div>
          </div>
        </div>

        <!-- Module 2: Extraction (æå–æŠ˜æ‰£ç ) -->
        <div class="feature-module" id="module-extraction">
          <h1 style="color:#6001d2; margin-bottom:20px;">ğŸ« æå–æŠ˜æ‰£ç </h1>
          
          <!-- Filter Card -->
          <div class="card" id="filterCard">
            <h2>ç­›é€‰æ¡ä»¶</h2>
            <div class="row">
              <div class="form-group">
                <label>æ–‡ä»¶å¤¹</label>
                <select id="folder"></select>
              </div>
              <div class="form-group">
                <label>å‘ä»¶äºº (å¯é€‰)</label>
                <input type="text" id="sender" placeholder="sender@example.com">
              </div>
            </div>
            <div class="row">
              <div class="form-group">
                <label>å¼€å§‹æ—¥æœŸ</label>
                <input type="date" id="dateFrom">
              </div>
              <div class="form-group">
                <label>ç»“æŸæ—¥æœŸ</label>
                <input type="date" id="dateTo">
              </div>
            </div>
            <div class="form-group">
              <label>ä¸»é¢˜åŒ…å« (å¯é€‰)</label>
              <input type="text" id="subject" placeholder="å…³é”®è¯">
            </div>
            <button onclick="countEmails()">ç»Ÿè®¡é‚®ä»¶æ•°é‡</button>
            <button class="btn-secondary" onclick="previewEmail()" style="margin-left:10px">é¢„è§ˆç¬¬ä¸€å°é‚®ä»¶</button>
            <div id="countResult" class="hidden status info"></div>
            
            <!-- Email Preview with Search - Requirements: 2.3, 2.4, 2.5 -->
            <div id="previewContainer" class="hidden" style="margin-top:15px;">
              <!-- Search Box - Requirements: 2.3, 2.4 -->
              <div class="preview-search-box" id="previewSearchBox">
                <input type="text" id="previewSearchInput" placeholder="åœ¨é‚®ä»¶ä¸­æœç´¢..." onkeydown="handlePreviewSearchKeydown(event)">
                <button class="search-nav-btn" onclick="searchInPreview()" title="æœç´¢">ğŸ”</button>
                <span class="search-count" id="previewSearchCount">0/0</span>
                <button class="search-nav-btn" onclick="navigatePreviewSearch('prev')" title="ä¸Šä¸€ä¸ª" id="previewSearchPrev" disabled>â–²</button>
                <button class="search-nav-btn" onclick="navigatePreviewSearch('next')" title="ä¸‹ä¸€ä¸ª" id="previewSearchNext" disabled>â–¼</button>
                <button class="search-clear-btn" onclick="clearPreviewSearch()" title="æ¸…é™¤æœç´¢">âœ•</button>
                <button class="preview-generate-rule-btn" onclick="generateRuleFromSelection()" id="generateRuleBtn" disabled title="é€‰æ‹©æ–‡æœ¬åå¯ç”Ÿæˆè§„åˆ™">ğŸ“‹ ç”Ÿæˆè§„åˆ™</button>
              </div>
              <!-- Preview Content -->
              <div id="previewResult" class="preview-content-wrapper"></div>
            </div>
          </div>

          <!-- Pattern Card -->
          <div class="card" id="patternCard">
            <h2>æå–æ¨¡å¼</h2>
            
            <!-- Rule History Section - Collapsible Panel -->
            <!-- Requirements: 1.1, 1.2, 1.3 -->
            <div class="card" id="ruleHistoryCard" style="margin-bottom:20px;">
              <div style="display:flex; justify-content:space-between; align-items:center; cursor:pointer;" onclick="toggleRuleHistoryPanel()">
                <h2 style="margin:0; display:flex; align-items:center; gap:8px;">
                  <span id="ruleHistoryToggleIcon">â–¼</span>
                  ğŸ“œ è§„åˆ™å†å²
                  <span id="ruleHistoryCount" style="font-size:12px; color:#666; font-weight:normal;"></span>
                </h2>
                <button class="btn-secondary" style="padding:4px 12px; font-size:12px;" onclick="event.stopPropagation(); loadRuleHistory();">ğŸ”„ åˆ·æ–°</button>
              </div>
              
              <div id="ruleHistoryContent" style="margin-top:15px;">
                <div id="ruleHistoryStatus"></div>
                
                <!-- Tag Filter -->
                <div id="ruleTagFilter" style="margin-bottom:10px; display:none;">
                  <label style="font-size:13px; color:#666; margin-right:8px;">æŒ‰æ ‡ç­¾ç­›é€‰:</label>
                  <select id="ruleTagSelect" onchange="filterRulesByTag()" style="padding:4px 8px; font-size:13px;">
                    <option value="">å…¨éƒ¨</option>
                  </select>
                </div>
                
                <div id="ruleHistoryList" style="max-height:400px; overflow-y:auto;">
                  <p style="color:#666;">åŠ è½½ä¸­...</p>
                </div>
              </div>
            </div>
            
            <!-- Rule Editor Panel - Requirements: 3.4, 4.1, 4.6 -->
            <div class="card" id="ruleEditorCard" style="margin-bottom:20px; border:2px solid #6001d2;">
              <h2 style="display:flex; align-items:center; gap:8px;">
                <span>ğŸ“</span> è§„åˆ™ç¼–è¾‘å™¨
                <span id="ruleEditorStatus" style="font-size:12px; color:#666; font-weight:normal; margin-left:auto;"></span>
              </h2>
              
              <!-- Target String Section - Requirements: 3.4 -->
              <div style="background:#f9f9f9; padding:15px; border-radius:4px; margin-bottom:15px; border:1px solid #e0e0e0;">
                <h3 style="color:#333; margin-bottom:10px; font-size:14px;">ğŸ¯ ç›®æ ‡å­—ç¬¦ä¸²</h3>
                <div style="display:flex; gap:10px; align-items:flex-end; flex-wrap:wrap;">
                  <div class="form-group" style="flex:1; margin-bottom:0; min-width:200px;">
                    <label>ä»é¢„è§ˆé‚®ä»¶ä¸­å¤åˆ¶ç›®æ ‡æ–‡æœ¬</label>
                    <input type="text" id="targetString" placeholder="ä¾‹å¦‚: BDAY-ABC123 æˆ– code: 50OFF">
                  </div>
                  <button onclick="openPatternBuilder()" style="background:#6001d2; white-space:nowrap;">ğŸ”§ æ™ºèƒ½ç”Ÿæˆ</button>
                  <button onclick="generateRuleFromTarget()" style="background:#28a745; white-space:nowrap;">ğŸ¤– å¿«é€Ÿç”Ÿæˆ</button>
                </div>
                
                <!-- Generated Pattern Suggestions -->
                <div id="generatedPatterns" class="hidden" style="margin-top:15px;">
                  <label style="font-weight:600; color:#6001d2; font-size:13px;">ç”Ÿæˆçš„è§„åˆ™å»ºè®®ï¼š</label>
                  <div id="patternsList" style="margin-top:10px;"></div>
                </div>
              </div>
              
              <!-- Editable Rule Fields - Requirements: 4.1 -->
              <div style="background:#fff9f0; padding:15px; border-radius:4px; margin-bottom:15px; border:1px solid #ffe0b2;">
                <h3 style="color:#333; margin-bottom:10px; font-size:14px;">âœï¸ è§„åˆ™å­—æ®µ</h3>
                
                <div class="form-group">
                  <label>æ¨¡å¼åç§° <span style="color:#dc3545;">*</span></label>
                  <input type="text" id="patternName" value="default" placeholder="ä¸ºè§„åˆ™èµ·ä¸€ä¸ªåç§°">
                </div>
                
                <div class="form-group">
                  <label>ä¸»é¢˜æ¨¡å¼ (ç”¨äºç­›é€‰é‚®ä»¶)</label>
                  <input type="text" id="ruleSubjectPattern" placeholder="ä¾‹å¦‚: Your.*discount.*code æˆ– ä¼˜æƒ ç ">
                </div>
                
                <div class="row">
                  <div class="form-group" style="flex:2;">
                    <label>æ­£åˆ™è¡¨è¾¾å¼ <span style="color:#dc3545;">*</span></label>
                    <input type="text" id="pattern" placeholder="ä¾‹å¦‚: (?<code>\d{6}) æˆ– [A-Z0-9]{8,12}">
                  </div>
                  <div class="form-group" style="flex:1;">
                    <label>æ ‡å¿—</label>
                    <select id="patternFlags">
                      <option value="g">g (å…¨å±€åŒ¹é…)</option>
                      <option value="gi">gi (å…¨å±€+å¿½ç•¥å¤§å°å†™)</option>
                      <option value="i">i (å¿½ç•¥å¤§å°å†™)</option>
                      <option value="gm">gm (å…¨å±€+å¤šè¡Œ)</option>
                      <option value="gim">gim (å…¨å±€+å¿½ç•¥å¤§å°å†™+å¤šè¡Œ)</option>
                    </select>
                  </div>
                </div>
                
                <div class="form-group">
                  <label>æ ‡ç­¾ (ç”¨é€—å·åˆ†éš”)</label>
                  <input type="text" id="patternTags" placeholder="ä¾‹å¦‚: æŠ˜æ‰£ç , ä¼˜æƒ åˆ¸, ç”µå•†">
                </div>
              </div>
              
              <!-- Validation Section - Requirements: 4.3, 4.4, 4.5 -->
              <div style="background:#f0f8f0; padding:15px; border-radius:4px; margin-bottom:15px; border:1px solid #b2dfb2;">
                <h3 style="color:#333; margin-bottom:10px; font-size:14px;">âœ… è§„åˆ™éªŒè¯</h3>
                <p style="color:#666; font-size:12px; margin-bottom:10px;">éªŒè¯æ­£åˆ™è¡¨è¾¾å¼è¯­æ³•å¹¶æµ‹è¯•åŒ¹é…æ•ˆæœ</p>
                <div style="display:flex; gap:10px; flex-wrap:wrap;">
                  <button onclick="validateRuleSyntax()" class="btn-secondary" style="font-size:13px;">ğŸ” éªŒè¯è¯­æ³•</button>
                  <button onclick="testRuleInPreview()" class="btn-secondary" style="font-size:13px;">ğŸ§ª æµ‹è¯•åŒ¹é…</button>
                  <button onclick="validateRegex()" class="btn-secondary" style="font-size:13px;">ğŸ“§ éªŒè¯é‚®ä»¶</button>
                </div>
                <div id="ruleValidationResult" class="hidden" style="margin-top:15px; padding:10px; background:white; border-radius:4px; border:1px solid #b2dfb2;"></div>
                <div id="validationResult" class="hidden" style="margin-top:15px; padding:10px; background:white; border-radius:4px; border:1px solid #b2dfb2;"></div>
              </div>
              
              <!-- Action Buttons - Requirements: 4.6 -->
              <div style="display:flex; gap:10px; flex-wrap:wrap; padding-top:10px; border-top:1px solid #e0e0e0;">
                <button onclick="saveRuleToHistory()" style="background:#6001d2;">ğŸ’¾ ä¿å­˜è§„åˆ™</button>
                <button onclick="useCurrentRule()" class="btn-secondary">â–¶ï¸ ä½¿ç”¨è§„åˆ™</button>
                <button onclick="clearRuleEditor()" class="btn-secondary" style="background:#dc3545;">ğŸ—‘ï¸ æ¸…ç©º</button>
              </div>
            </div>
          </div>

            <!-- Extraction Options -->
            <div class="card" id="extractionOptionsCard">
              <h2>âš™ï¸ æå–é€‰é¡¹</h2>
              
              <!-- Current Rule Display -->
              <div id="currentRuleDisplay" class="hidden" style="margin-bottom:15px; padding:12px; background:#f0e6ff; border-radius:6px; border:1px solid #d4c4e8;">
                <div style="display:flex; justify-content:space-between; align-items:flex-start;">
                  <div style="flex:1;">
                    <div style="font-weight:600; color:#6001d2; margin-bottom:4px;">
                      ğŸ“‹ <span id="currentRuleName">æœªå‘½åè§„åˆ™</span>
                    </div>
                    <div style="font-size:13px; color:#333; margin-bottom:4px;">
                      ä¸»é¢˜: <span id="currentRuleSubject">(æ— ä¸»é¢˜ç­›é€‰)</span>
                    </div>
                    <code style="font-size:11px; color:#666; background:#fff; padding:4px 8px; border-radius:3px; display:block; word-break:break-all;" id="currentRuleRegex"></code>
                    <div style="font-size:11px; color:#888; margin-top:4px;">
                      æ ‡å¿—: <span id="currentRuleFlags">g</span>
                      <span id="currentRuleTags" style="margin-left:10px;"></span>
                    </div>
                  </div>
                  <button onclick="clearCurrentRule()" style="background:#dc3545; padding:4px 8px; font-size:11px; margin-left:10px;">âœ• æ¸…é™¤</button>
                </div>
              </div>
              
              <div class="checkbox-group">
                <input type="checkbox" id="stripHtml">
                <label for="stripHtml">æå–å‰å»é™¤ HTML æ ‡ç­¾</label>
              </div>
              <div class="form-group" style="margin-top:15px;">
                <label>æå–é€Ÿåº¦ (æ¯å°é‚®ä»¶å»¶è¿Ÿ ms)</label>
                <div style="display:flex; gap:10px; align-items:center;">
                  <input type="range" id="delayMs" min="0" max="1000" value="100" style="flex:1;">
                  <span id="delayValue" style="min-width:50px; text-align:right;">100ms</span>
                </div>
                <small style="color:#666;">å€¼è¶Šå¤§ï¼Œæå–è¶Šæ…¢ï¼ŒCPU å ç”¨è¶Šä½ã€‚å»ºè®® 100-500ms</small>
              </div>
              <div class="form-group" style="margin-top:15px;">
                <label>è·³è¿‡å·²å¤„ç†é‚®ä»¶ï¼ˆæ–­ç‚¹ç»­ä¼ ï¼‰</label>
                <div style="display:flex; gap:10px; align-items:center;">
                  <input type="number" id="skipCount" min="0" value="0" style="width:100px;">
                  <span style="color:#666; font-size:13px;">å°é‚®ä»¶</span>
                  <button type="button" onclick="document.getElementById('skipCount').value='0'" style="padding:4px 8px; font-size:12px; background:#666;">é‡ç½®</button>
                </div>
                <small style="color:#666;">å¦‚æœä¸Šæ¬¡æå–ä¸­æ–­ï¼Œå¯ä»¥è¾“å…¥å·²å¤„ç†çš„é‚®ä»¶æ•°ï¼Œä»æ–­ç‚¹ç»§ç»­</small>
              </div>
              <br>
              <button id="extractBtn" onclick="extract()" disabled style="opacity:0.5; cursor:not-allowed;">ğŸš€ å¼€å§‹æå–</button>
              <small id="extractBtnHint" style="color:#999; margin-left:10px;">è¯·å…ˆé€‰æ‹©æˆ–åˆ›å»ºä¸€ä¸ªè§„åˆ™</small>
            </div>

          <!-- Results Card -->
          <div class="card hidden" id="resultsCard">
            <h2>æå–ç»“æœ</h2>
            <div id="extractStatus"></div>
            <!-- Resume buttons (hidden by default) -->
            <div id="resumeButtons" style="display:none; margin:15px 0; padding:15px; background:#fff3e0; border-radius:6px; border:1px solid #ffcc80;">
              <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
                <button onclick="reconnectAndResume()" style="background:#ff9800; color:white;">ğŸ”„ é‡æ–°è¿æ¥</button>
                <button onclick="continueExtract()" id="continueExtractBtn" style="background:#4caf50; color:white;" disabled>â–¶ï¸ ç»§ç»­æå–</button>
                <span id="resumeStatus" style="color:#666; font-size:13px;"></span>
              </div>
              <p style="margin:10px 0 0 0; font-size:12px; color:#666;">
                ğŸ’¡ æç¤ºï¼šç‚¹å‡»"é‡æ–°è¿æ¥"åï¼Œç­‰å¾…è¿æ¥æˆåŠŸï¼Œå†ç‚¹å‡»"ç»§ç»­æå–"ä»æ–­ç‚¹ç»§ç»­
              </p>
            </div>
            <div style="margin-bottom:15px;">
              <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
                <span id="progressText">å‡†å¤‡ä¸­...</span>
                <span id="progressPercent">0%</span>
              </div>
              <div class="progress">
                <div class="progress-bar" id="progressBar" style="width:0%"></div>
              </div>
            </div>
            <div id="liveMatches" style="margin-bottom:15px; padding:10px; background:#f0f8ff; border-radius:4px; max-height:300px; overflow-y:auto; border:1px solid #b0d4ff;">
              <strong>å®æ—¶æå–ç»“æœï¼š</strong>
              <div id="matchesList" style="margin-top:10px; font-size:13px;"></div>
            </div>
            <div id="results"></div>
            <br>
            <button onclick="exportCSV()">å¯¼å‡º CSV</button>
          </div>
        </div>

        <!-- Module 3: Email Management -->
        <div class="feature-module" id="module-email-management">
          <h1 style="color:#6001d2; margin-bottom:20px;">ğŸ“§ é‚®ä»¶ç®¡ç†</h1>
          
          <!-- Connection Required Notice -->
          <div class="card" id="emailMgmtConnectionNotice">
            <div style="text-align:center; padding:30px;">
              <p style="font-size:48px; margin-bottom:15px;">ğŸ”Œ</p>
              <h3 style="color:#333; margin-bottom:10px;">è¯·å…ˆè¿æ¥é‚®ç®±</h3>
              <p style="color:#666; margin-bottom:20px;">åœ¨ä½¿ç”¨é‚®ä»¶ç®¡ç†åŠŸèƒ½å‰ï¼Œè¯·å…ˆåœ¨"é‚®ç®±ç®¡ç†"ä¸­è¿æ¥æ‚¨çš„é‚®ç®±è´¦æˆ·ã€‚</p>
              <button onclick="switchModule('mailbox-management')">å‰å¾€é‚®ç®±ç®¡ç†</button>
            </div>
          </div>
          
          <!-- Email Management Main Content (hidden until connected) -->
          <div id="emailMgmtContent" style="display:none;">
            <!-- Email Management Layout -->
            <div style="display:flex; gap:20px;">
              <!-- Folder Sidebar -->
              <div class="card" style="width:220px; flex-shrink:0;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                  <h2 style="font-size:16px; margin:0;">ğŸ“ æ–‡ä»¶å¤¹</h2>
                  <button onclick="showFolderManager()" class="btn-secondary" style="padding:4px 8px; font-size:12px;">âš™ï¸ ç®¡ç†</button>
                </div>
                <div id="emailFolderList" style="margin-top:10px;">
                  <p style="color:#666; font-size:13px;">åŠ è½½ä¸­...</p>
                </div>
              </div>
              
              <!-- Email List Area -->
              <div class="card" style="flex:1; min-width:0;">
                <h2 style="font-size:16px;">ğŸ“¬ é‚®ä»¶åˆ—è¡¨</h2>
                
                <!-- Search Bar -->
                <div style="display:flex; gap:10px; margin-bottom:15px; flex-wrap:wrap;">
                  <div style="flex:1; min-width:200px;">
                    <input type="text" id="emailSearchPattern" placeholder="æœç´¢ä¸»é¢˜å…³é”®è¯..." style="width:100%;">
                  </div>
                  <button onclick="searchEmails()">ğŸ” æœç´¢</button>
                  <button class="btn-secondary" onclick="clearEmailSearch()">æ¸…é™¤</button>
                </div>
                
                <!-- Action Buttons -->
                <div style="display:flex; gap:10px; margin-bottom:15px; flex-wrap:wrap; align-items:center;">
                  <div style="display:flex; align-items:center; gap:5px;">
                    <input type="checkbox" id="selectAllEmails" onchange="toggleSelectAllEmails()">
                    <label for="selectAllEmails" style="margin:0; font-size:13px; cursor:pointer;">å…¨é€‰</label>
                  </div>
                  <button class="btn-danger" onclick="batchDeleteSelectedEmails()" id="btnBatchDelete" disabled>ğŸ—‘ï¸ åˆ é™¤é€‰ä¸­ (<span id="selectedCount">0</span>)</button>
                  <button class="btn-secondary" onclick="showMoveEmailsModal()" id="btnMoveEmails" disabled>ğŸ“‚ ç§»åŠ¨é€‰ä¸­</button>
                  <button class="btn-secondary" onclick="refreshEmailList()">ğŸ”„ åˆ·æ–°</button>
                  
                  <!-- View Mode Toggle -->
                  <div style="display:flex; align-items:center; gap:5px; margin-left:10px; border:1px solid #ddd; border-radius:4px; overflow:hidden;">
                    <button id="btnListView" onclick="switchEmailViewMode('list')" style="padding:6px 12px; font-size:12px; border:none; background:#6001d2; color:white; cursor:pointer;">ğŸ“‹ åˆ—è¡¨</button>
                    <button id="btnConversationView" onclick="switchEmailViewMode('conversation')" style="padding:6px 12px; font-size:12px; border:none; background:#f0f0f0; color:#333; cursor:pointer;">ğŸ’¬ ä¼šè¯</button>
                  </div>
                  
                  <div style="display:flex; align-items:center; gap:5px; margin-left:10px;">
                    <label style="margin:0; font-size:13px;">æ’åº:</label>
                    <select id="emailSortOrder" onchange="changeEmailSortOrder()" style="padding:4px 8px; font-size:13px;">
                      <option value="desc">æ—¥æœŸ â†“ (æœ€æ–°)</option>
                      <option value="asc">æ—¥æœŸ â†‘ (æœ€æ—©)</option>
                    </select>
                  </div>
                  <span id="emailListStatus" style="font-size:13px; color:#666;"></span>
                </div>
                
                <!-- Email Table -->
                <div style="overflow-x:auto;">
                  <table id="emailTable" style="width:100%; min-width:600px;">
                    <thead>
                      <tr>
                        <th style="width:40px;"></th>
                        <th style="width:120px;">æ—¥æœŸ</th>
                        <th style="width:180px;">å‘ä»¶äºº</th>
                        <th>ä¸»é¢˜</th>
                      </tr>
                    </thead>
                    <tbody id="emailTableBody">
                      <tr>
                        <td colspan="4" style="text-align:center; padding:30px; color:#666;">
                          é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶å¤¹ä»¥æŸ¥çœ‹é‚®ä»¶
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                
                <!-- Pagination Controls -->
                <div id="emailPagination" style="display:flex; justify-content:space-between; align-items:center; margin-top:15px; padding-top:15px; border-top:1px solid #eee;">
                  <div style="font-size:13px; color:#666;">
                    <span id="paginationInfo">-</span>
                  </div>
                  <div style="display:flex; gap:5px; align-items:center;">
                    <button class="btn-secondary" id="btnPrevPage" onclick="goToEmailPage('prev')" disabled style="padding:8px 12px;">â—€ ä¸Šä¸€é¡µ</button>
                    <span id="pageIndicator" style="padding:0 10px; font-size:13px;">ç¬¬ 1 é¡µ</span>
                    <button class="btn-secondary" id="btnNextPage" onclick="goToEmailPage('next')" disabled style="padding:8px 12px;">ä¸‹ä¸€é¡µ â–¶</button>
                    <select id="pageSizeSelect" onchange="changePageSize()" style="margin-left:10px; padding:6px;">
                      <option value="10">10 æ¡/é¡µ</option>
                      <option value="20" selected>20 æ¡/é¡µ</option>
                      <option value="50">50 æ¡/é¡µ</option>
                      <option value="100">100 æ¡/é¡µ</option>
                    </select>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Legacy Email Management Card -->
            <div class="card" id="managementCard" style="margin-top:20px;">
              <h2>âš ï¸ é«˜çº§æ“ä½œ</h2>
              <div style="background:#fff3e0; padding:15px; border-radius:4px; margin-bottom:15px; border:1px solid #ffcc80;">
                <p style="color:#e65100; margin:0; font-size:13px;">âš ï¸ è­¦å‘Šï¼šåˆ é™¤æ“ä½œä¸å¯æ’¤é”€ï¼è¯·è°¨æ…æ“ä½œã€‚</p>
              </div>
              
              <div class="row">
                <div class="form-group">
                  <label>å›æ”¶ç«™ç®¡ç†</label>
                  <p style="color:#666; font-size:12px; margin:5px 0;">æŸ¥çœ‹æˆ–æ¸…ç©ºå›æ”¶ç«™ä¸­çš„é‚®ä»¶</p>
                  <div style="display:flex; gap:10px;">
                    <button class="btn-secondary" onclick="getTrashCount()">æŸ¥çœ‹å›æ”¶ç«™</button>
                    <button class="btn-danger" onclick="emptyTrash()">ğŸ—‘ï¸ æ¸…ç©ºå›æ”¶ç«™</button>
                  </div>
                </div>
              </div>
              <div id="managementResult" class="hidden status info"></div>
            </div>
          </div>
        </div>

        <!-- Module 4: Settings / Data Management -->
        <div class="feature-module" id="module-settings">
          <h1 style="color:#6001d2; margin-bottom:20px;">âš™ï¸ æ•°æ®ç®¡ç†</h1>
          
          <!-- Export Data Card -->
          <div class="card">
            <h2>ğŸ“¤ å¯¼å‡ºæ•°æ®</h2>
            <p style="color:#666; font-size:13px; margin-bottom:15px;">å¯¼å‡ºæ‚¨çš„é‚®ç®±é…ç½®å’Œæå–è§„åˆ™ï¼Œå¯ç”¨äºå¤‡ä»½æˆ–è¿ç§»åˆ°å…¶ä»–è®¾å¤‡ã€‚</p>
            <button onclick="exportUserData()" style="background:#28a745; color:white; padding:10px 20px; border:none; border-radius:4px; cursor:pointer;">
              ğŸ“¥ ä¸‹è½½æ•°æ®å¤‡ä»½
            </button>
          </div>
          
          <!-- Import Data Card -->
          <div class="card" style="margin-top:20px;">
            <h2>ğŸ“¥ å¯¼å…¥æ•°æ®</h2>
            <p style="color:#666; font-size:13px; margin-bottom:15px;">ä»å¤‡ä»½æ–‡ä»¶æ¢å¤æ‚¨çš„é‚®ç®±é…ç½®å’Œæå–è§„åˆ™ã€‚</p>
            
            <div class="settings-checkbox">
              <input type="checkbox" id="importMergeMode" checked>
              <span>åˆå¹¶æ¨¡å¼ï¼ˆè·³è¿‡å·²å­˜åœ¨çš„æ•°æ®ï¼‰</span>
            </div>
            
            <div class="settings-checkbox">
              <input type="checkbox" id="importMailboxes" checked>
              <span>å¯¼å…¥é‚®ç®±é…ç½®</span>
            </div>
            
            <div class="settings-checkbox">
              <input type="checkbox" id="importPatterns" checked>
              <span>å¯¼å…¥æå–è§„åˆ™</span>
            </div>
            
            <input type="file" id="importFileInput" accept=".json" style="display:none;" onchange="handleImportFile(event)">
            <button onclick="document.getElementById('importFileInput').click()" style="background:#007bff; color:white; padding:10px 20px; border:none; border-radius:4px; cursor:pointer;">
              ğŸ“‚ é€‰æ‹©å¤‡ä»½æ–‡ä»¶
            </button>
            <div id="importResult" style="margin-top:15px;"></div>
          </div>
          
          <!-- Clear Data Card -->
          <div class="card" style="margin-top:20px;">
            <h2>ğŸ—‘ï¸ æ¸…é™¤æ•°æ®</h2>
            <div style="background:#fff3e0; padding:15px; border-radius:4px; margin-bottom:15px; border:1px solid #ffcc80;">
              <p style="color:#e65100; margin:0; font-size:13px;">âš ï¸ è­¦å‘Šï¼šæ­¤æ“ä½œä¸å¯æ’¤é”€ï¼å»ºè®®å…ˆå¯¼å‡ºå¤‡ä»½ã€‚</p>
            </div>
            
            <div class="settings-checkbox">
              <input type="checkbox" id="clearMailboxes">
              <span>æ¸…é™¤æ‰€æœ‰é‚®ç®±é…ç½®</span>
            </div>
            
            <div class="settings-checkbox">
              <input type="checkbox" id="clearPatterns">
              <span>æ¸…é™¤æ‰€æœ‰æå–è§„åˆ™</span>
            </div>
            
            <button onclick="clearUserData()" class="btn-danger" style="padding:10px 20px;">
              ğŸ—‘ï¸ æ¸…é™¤é€‰ä¸­çš„æ•°æ®
            </button>
            <div id="clearResult" style="margin-top:15px;"></div>
          </div>
        </div>
      </main>
    </div>
  </div>

  <!-- Email Content Modal -->
  <div class="email-modal-overlay" id="emailModal" onclick="closeEmailModal(event)">
    <div class="email-modal" onclick="event.stopPropagation()">
      <div class="email-modal-header">
        <h3 id="emailModalSubject">é‚®ä»¶ä¸»é¢˜</h3>
        <button class="email-modal-close" onclick="closeEmailModal()">&times;</button>
      </div>
      <div class="email-modal-meta">
        <p><strong>å‘ä»¶äºº:</strong> <span id="emailModalFrom"></span></p>
        <p><strong>æ”¶ä»¶äºº:</strong> <span id="emailModalTo"></span></p>
        <p><strong>æ—¥æœŸ:</strong> <span id="emailModalDate"></span></p>
      </div>
      <div class="email-modal-body" id="emailModalBody">
        <div class="email-modal-loading">åŠ è½½ä¸­...</div>
      </div>
    </div>
  </div>

  <!-- Pattern Builder Modal -->
  <div class="email-modal-overlay" id="patternBuilderModal" onclick="closePatternBuilder(event)">
    <div class="pattern-builder-modal" onclick="event.stopPropagation()">
      <div class="email-modal-header">
        <h3>ğŸ”§ æ™ºèƒ½è§„åˆ™ç”Ÿæˆå™¨</h3>
        <button class="email-modal-close" onclick="closePatternBuilder()">&times;</button>
      </div>
      <div class="pattern-builder-body">
        <!-- Analyzed parts display -->
        <div class="analyzed-parts" id="analyzedParts">
          <div class="analyzed-parts-title">ğŸ“Š è‡ªåŠ¨åˆ†æç»“æœ</div>
          <div class="analyzed-parts-content" id="analyzedPartsContent"></div>
        </div>

        <!-- Part 1: Prefix keywords -->
        <div class="pattern-part">
          <div class="pattern-part-header">
            <label><span class="part-badge">1</span> æç¤ºè¯å‰ç¼€</label>
            <div class="pattern-part-toggle">
              <input type="checkbox" id="enablePrefix" checked onchange="updatePatternPreview()">
              <span>å¯ç”¨</span>
            </div>
          </div>
          <div class="pattern-part-content">
            <input type="text" id="prefixKeywords" placeholder="code|ä»£ç |ä¼˜æƒ ç |æŠ˜æ‰£ç " onchange="updatePatternPreview()" oninput="updatePatternPreview()">
            <div class="quick-prefix-btns">
              <button class="quick-prefix-btn" onclick="addPrefixKeyword('code')">code</button>
              <button class="quick-prefix-btn" onclick="addPrefixKeyword('ä»£ç ')">ä»£ç </button>
              <button class="quick-prefix-btn" onclick="addPrefixKeyword('ä¼˜æƒ ç ')">ä¼˜æƒ ç </button>
              <button class="quick-prefix-btn" onclick="addPrefixKeyword('æŠ˜æ‰£ç ')">æŠ˜æ‰£ç </button>
              <button class="quick-prefix-btn" onclick="addPrefixKeyword('å…‘æ¢ç ')">å…‘æ¢ç </button>
              <button class="quick-prefix-btn" onclick="addPrefixKeyword('promo')">promo</button>
              <button class="quick-prefix-btn" onclick="addPrefixKeyword('coupon')">coupon</button>
              <button class="quick-prefix-btn" onclick="addPrefixKeyword('use')">use</button>
            </div>
            <div class="pattern-part-hint">å¤šä¸ªå…³é”®è¯ç”¨ | åˆ†éš”ï¼ŒåŒ¹é…æ—¶ä¸åŒºåˆ†å¤§å°å†™</div>
          </div>
        </div>

        <!-- Part 2: Code segments (dynamically generated) -->
        <div class="pattern-part">
          <div class="pattern-part-header">
            <label><span class="part-badge">2</span> ç çš„ç»„æˆéƒ¨åˆ†</label>
          </div>
          <div class="pattern-part-content">
            <div class="pattern-part-hint" style="margin-bottom:10px;">
              æ£€æµ‹åˆ°çš„åˆ†éš”ç¬¦: <strong id="detectedSeparator">-</strong>ï¼Œ
              ç ç”± <strong id="segmentCount">1</strong> éƒ¨åˆ†ç»„æˆ
            </div>
            <div id="codeSegmentsContainer">
              <!-- Segments will be dynamically generated here -->
            </div>
          </div>
        </div>

        <!-- Pattern Preview -->
        <div>
          <label style="font-weight:600; color:#333; margin-bottom:8px; display:block;">ğŸ“ ç”Ÿæˆçš„æ­£åˆ™è¡¨è¾¾å¼</label>
          <div class="pattern-preview-box" id="patternPreviewBox">
            <span class="regex-group">(?&lt;code&gt;</span><span class="regex-variable">[A-Z0-9]{4,12}</span><span class="regex-group">)</span>
          </div>
        </div>
      </div>
      <div class="pattern-builder-actions">
        <button onclick="closePatternBuilder()" class="btn-secondary">å–æ¶ˆ</button>
        <button onclick="applyBuiltPattern()" style="background:#28a745; color:white;">âœ“ åº”ç”¨è§„åˆ™</button>
      </div>
    </div>
  </div>

  <!-- Folder Manager Modal -->
  <div class="email-modal-overlay" id="folderManagerModal" onclick="closeFolderManager(event)">
    <div class="email-modal" style="max-width:500px;" onclick="event.stopPropagation()">
      <div class="email-modal-header">
        <h3>ğŸ“ æ–‡ä»¶å¤¹ç®¡ç†</h3>
        <button class="email-modal-close" onclick="closeFolderManager()">&times;</button>
      </div>
      <div class="email-modal-body" style="padding:20px;">
        <!-- Create Folder -->
        <div style="margin-bottom:20px;">
          <h4 style="margin-bottom:10px; color:#333;">â• æ–°å»ºæ–‡ä»¶å¤¹</h4>
          <div style="display:flex; gap:10px;">
            <input type="text" id="newFolderName" placeholder="è¾“å…¥æ–‡ä»¶å¤¹åç§°" style="flex:1;">
            <button onclick="createFolder()" style="white-space:nowrap;">åˆ›å»º</button>
          </div>
        </div>
        
        <!-- Folder List -->
        <div>
          <h4 style="margin-bottom:10px; color:#333;">ğŸ“‚ ç°æœ‰æ–‡ä»¶å¤¹</h4>
          <div id="folderManagerList" style="max-height:300px; overflow-y:auto;">
            <div style="text-align:center; color:#999; padding:20px;">åŠ è½½ä¸­...</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Move Emails Modal -->
  <div class="email-modal-overlay" id="moveEmailsModal" onclick="closeMoveEmailsModal(event)">
    <div class="email-modal" style="max-width:400px;" onclick="event.stopPropagation()">
      <div class="email-modal-header">
        <h3>ğŸ“‚ ç§»åŠ¨é‚®ä»¶</h3>
        <button class="email-modal-close" onclick="closeMoveEmailsModal()">&times;</button>
      </div>
      <div class="email-modal-body" style="padding:20px;">
        <p style="margin-bottom:15px; color:#666;">
          å°† <strong id="moveEmailCount">0</strong> å°é€‰ä¸­çš„é‚®ä»¶ç§»åŠ¨åˆ°:
        </p>
        <select id="moveTargetFolder" style="width:100%; padding:10px; margin-bottom:20px;">
          <option value="">-- é€‰æ‹©ç›®æ ‡æ–‡ä»¶å¤¹ --</option>
        </select>
        <div style="display:flex; gap:10px; justify-content:flex-end;">
          <button onclick="closeMoveEmailsModal()" class="btn-secondary">å–æ¶ˆ</button>
          <button onclick="moveSelectedEmails()" id="btnConfirmMove">ç¡®è®¤ç§»åŠ¨</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Rename Folder Modal -->
  <div class="email-modal-overlay" id="renameFolderModal" onclick="closeRenameFolderModal(event)">
    <div class="email-modal" style="max-width:400px;" onclick="event.stopPropagation()">
      <div class="email-modal-header">
        <h3>âœï¸ é‡å‘½åæ–‡ä»¶å¤¹</h3>
        <button class="email-modal-close" onclick="closeRenameFolderModal()">&times;</button>
      </div>
      <div class="email-modal-body" style="padding:20px;">
        <p style="margin-bottom:10px; color:#666;">
          åŸåç§°: <strong id="oldFolderNameDisplay"></strong>
        </p>
        <input type="hidden" id="oldFolderName">
        <div style="margin-bottom:20px;">
          <label style="display:block; margin-bottom:5px;">æ–°åç§°:</label>
          <input type="text" id="newFolderNameInput" placeholder="è¾“å…¥æ–°åç§°" style="width:100%;">
        </div>
        <div style="display:flex; gap:10px; justify-content:flex-end;">
          <button onclick="closeRenameFolderModal()" class="btn-secondary">å–æ¶ˆ</button>
          <button onclick="confirmRenameFolder()">ç¡®è®¤é‡å‘½å</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    const API = '';
    let sessionId = null;
    let extractedResults = [];
    let authToken = null;
    let currentUser = null;

    // ==================== API Client with Auth Token ====================
    
    /**
     * Centralized API client that automatically includes auth token
     * and handles 401 responses by redirecting to login.
     * Requirements: 7.1, 7.2, 7.3
     */
    async function apiRequest(endpoint, options = {}) {
      const headers = {
        'Content-Type': 'application/json',
        ...(options.headers || {})
      };
      
      // Add Authorization header if we have a token
      if (authToken) {
        headers['Authorization'] = `Bearer ${authToken}`;
      }
      
      const fetchOptions = {
        ...options,
        headers
      };
      
      try {
        const response = await fetch(`${API}${endpoint}`, fetchOptions);
        
        // Handle 401 Unauthorized - redirect to login
        if (response.status === 401) {
          console.log('[API] Received 401, redirecting to login');
          // Clear session data
          authToken = null;
          currentUser = null;
          sessionStorage.removeItem('authToken');
          sessionStorage.removeItem('currentUser');
          // Redirect to login page
          showLoginPage();
          throw new Error('Session expired, please login again');
        }
        
        return response;
      } catch (error) {
        // Re-throw the error for the caller to handle
        throw error;
      }
    }
    
    /**
     * Convenience method for GET requests with auth
     */
    async function apiGet(endpoint) {
      return apiRequest(endpoint, { method: 'GET' });
    }
    
    /**
     * Convenience method for POST requests with auth
     */
    async function apiPost(endpoint, body) {
      return apiRequest(endpoint, {
        method: 'POST',
        body: JSON.stringify(body)
      });
    }
    
    /**
     * Convenience method for DELETE requests with auth
     */
    async function apiDelete(endpoint, body = null) {
      const options = { method: 'DELETE' };
      if (body) {
        options.body = JSON.stringify(body);
      }
      return apiRequest(endpoint, options);
    }
    
    /**
     * Convenience method for PUT requests with auth
     */
    async function apiPut(endpoint, body) {
      return apiRequest(endpoint, {
        method: 'PUT',
        body: JSON.stringify(body)
      });
    }

    // ==================== Authentication Functions ====================
    
    // Show login error message
    function showLoginError(message) {
      const errorEl = document.getElementById('loginError');
      errorEl.textContent = message;
      errorEl.classList.add('visible');
    }

    // Hide login error message
    function hideLoginError() {
      const errorEl = document.getElementById('loginError');
      errorEl.classList.remove('visible');
    }

    // Show login success message
    function showLoginSuccess(message) {
      const successEl = document.getElementById('loginSuccess');
      successEl.textContent = message;
      successEl.classList.add('visible');
    }

    // Hide login success message
    function hideLoginSuccess() {
      const successEl = document.getElementById('loginSuccess');
      successEl.classList.remove('visible');
    }

    // Handle login form submission
    async function handleAuthSubmit(event) {
      event.preventDefault();
      
      const username = document.getElementById('authUsername').value.trim();
      const password = document.getElementById('authPassword').value;
      
      if (!username || !password) {
        showLoginError('è¯·è¾“å…¥ç”¨æˆ·åå’Œå¯†ç ');
        return;
      }

      const submitBtn = document.getElementById('authSubmitBtn');
      submitBtn.disabled = true;
      submitBtn.textContent = 'ç™»å½•ä¸­...';
      
      hideLoginError();
      hideLoginSuccess();

      try {
        // Use direct fetch for auth endpoints (no token needed yet)
        const res = await fetch(`${API}/api/auth/login`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username, password })
        });

        const data = await res.json();

        if (!res.ok) {
          showLoginError(data.error || 'ç™»å½•å¤±è´¥');
          return;
        }

        // Login successful
        authToken = data.token;
        currentUser = data.user;
        sessionStorage.setItem('authToken', authToken);
        sessionStorage.setItem('currentUser', JSON.stringify(currentUser));
        showMainApp();
      } catch (e) {
        showLoginError('ç½‘ç»œé”™è¯¯: ' + e.message);
      } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = 'ç™»å½•';
      }
    }

    // ==================== User Data Export/Import Functions ====================
    
    // Export user data
    async function exportUserData() {
      try {
        const res = await apiGet('/api/user/export');
        if (!res.ok) {
          throw new Error('å¯¼å‡ºå¤±è´¥');
        }
        
        const data = await res.json();
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `user-data-${new Date().toISOString().slice(0,10)}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        alert(`å¯¼å‡ºæˆåŠŸï¼\né‚®ç®±: ${data.mailboxes?.length || 0} ä¸ª\nè§„åˆ™: ${data.patterns?.length || 0} ä¸ª`);
      } catch (e) {
        alert('å¯¼å‡ºå¤±è´¥: ' + e.message);
      }
    }
    
    // Handle import file selection
    async function handleImportFile(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      const resultEl = document.getElementById('importResult');
      
      try {
        const text = await file.text();
        const data = JSON.parse(text);
        
        if (!data.mailboxes && !data.patterns) {
          throw new Error('æ— æ•ˆçš„å¤‡ä»½æ–‡ä»¶æ ¼å¼');
        }
        
        const mergeMode = document.getElementById('importMergeMode').checked;
        const importMailboxes = document.getElementById('importMailboxes').checked;
        const importPatterns = document.getElementById('importPatterns').checked;
        
        if (!importMailboxes && !importPatterns) {
          resultEl.innerHTML = '<p style="color:#dc3545;">è¯·è‡³å°‘é€‰æ‹©ä¸€é¡¹è¦å¯¼å…¥çš„æ•°æ®</p>';
          return;
        }
        
        const res = await apiPost('/api/user/import', {
          data,
          options: { merge: mergeMode, importMailboxes, importPatterns }
        });
        
        const result = await res.json();
        
        if (result.success) {
          resultEl.innerHTML = `
            <p style="color:#28a745;">âœ… å¯¼å…¥æˆåŠŸï¼</p>
            <p style="font-size:13px; color:#666;">
              é‚®ç®±: å¯¼å…¥ ${result.imported.mailboxes} ä¸ªï¼Œè·³è¿‡ ${result.skipped.mailboxes} ä¸ª<br>
              è§„åˆ™: å¯¼å…¥ ${result.imported.patterns} ä¸ªï¼Œè·³è¿‡ ${result.skipped.patterns} ä¸ª
            </p>
          `;
          // Refresh mailbox list if on that module
          if (document.getElementById('module-mailbox-management').classList.contains('active')) {
            loadMailboxes();
          }
        } else {
          resultEl.innerHTML = `<p style="color:#dc3545;">âŒ å¯¼å…¥å¤±è´¥: ${result.error}</p>`;
        }
      } catch (e) {
        resultEl.innerHTML = `<p style="color:#dc3545;">âŒ å¯¼å…¥å¤±è´¥: ${e.message}</p>`;
      }
      
      // Reset file input
      event.target.value = '';
    }
    
    // Clear user data
    async function clearUserData() {
      const clearMailboxes = document.getElementById('clearMailboxes').checked;
      const clearPatterns = document.getElementById('clearPatterns').checked;
      
      if (!clearMailboxes && !clearPatterns) {
        alert('è¯·è‡³å°‘é€‰æ‹©ä¸€é¡¹è¦æ¸…é™¤çš„æ•°æ®');
        return;
      }
      
      const items = [];
      if (clearMailboxes) items.push('é‚®ç®±é…ç½®');
      if (clearPatterns) items.push('æå–è§„åˆ™');
      
      if (!confirm(`ç¡®å®šè¦æ¸…é™¤ä»¥ä¸‹æ•°æ®å—ï¼Ÿ\n\n${items.join('\n')}\n\næ­¤æ“ä½œä¸å¯æ’¤é”€ï¼`)) {
        return;
      }
      
      const resultEl = document.getElementById('clearResult');
      
      try {
        const res = await apiDelete('/api/user/data', { clearMailboxes, clearPatterns });
        const result = await res.json();
        
        if (result.success) {
          resultEl.innerHTML = `
            <p style="color:#28a745;">âœ… æ¸…é™¤æˆåŠŸï¼</p>
            <p style="font-size:13px; color:#666;">
              é‚®ç®±: æ¸…é™¤ ${result.cleared.mailboxes} ä¸ª<br>
              è§„åˆ™: æ¸…é™¤ ${result.cleared.patterns} ä¸ª
            </p>
          `;
          // Uncheck boxes
          document.getElementById('clearMailboxes').checked = false;
          document.getElementById('clearPatterns').checked = false;
          // Refresh mailbox list
          loadMailboxes();
        } else {
          resultEl.innerHTML = `<p style="color:#dc3545;">âŒ æ¸…é™¤å¤±è´¥: ${result.error}</p>`;
        }
      } catch (e) {
        resultEl.innerHTML = `<p style="color:#dc3545;">âŒ æ¸…é™¤å¤±è´¥: ${e.message}</p>`;
      }
    }

    // Handle logout
    async function handleLogout() {
      if (!confirm('ç¡®å®šè¦é€€å‡ºç™»å½•å—ï¼Ÿ')) {
        return;
      }

      try {
        if (authToken) {
          await apiPost('/api/auth/logout', {});
        }
      } catch (e) {
        console.error('Logout error:', e);
      }

      // Clear session
      authToken = null;
      currentUser = null;
      sessionStorage.removeItem('authToken');
      sessionStorage.removeItem('currentUser');
      
      // Disconnect from mailbox if connected
      if (sessionId) {
        try {
          await apiPost('/api/disconnect', { sessionId });
        } catch (e) {
          console.error('Disconnect error:', e);
        }
        sessionId = null;
      }

      // Show login page
      showLoginPage();
    }

    // Show login page
    function showLoginPage() {
      document.getElementById('loginPage').style.display = 'flex';
      document.getElementById('mainApp').classList.remove('visible');
      
      // Reset form
      document.getElementById('authUsername').value = '';
      document.getElementById('authPassword').value = '';
      hideLoginError();
      hideLoginSuccess();
    }

    // Show main app
    function showMainApp() {
      document.getElementById('loginPage').style.display = 'none';
      document.getElementById('mainApp').classList.add('visible');
      
      // Update username in sidebar
      const username = currentUser?.username || 'Unknown';
      document.getElementById('sidebarUsername').textContent = username;
      
      // Check server status
      checkServerStatus();
      
      // Load saved mailboxes
      loadMailboxes();
      
      // Set default module to mailbox management
      switchModule('mailbox-management');
    }

    // ==================== Mailbox Management Functions ====================
    
    // Provider display names
    const providerNames = {
      'yahoo': 'Yahoo',
      'gmail': 'Gmail',
      'custom': 'è‡ªå®šä¹‰'
    };
    
    // Provider icons
    const providerIcons = {
      'yahoo': 'ğŸ“§',
      'gmail': 'ğŸ“¬',
      'custom': 'âœ‰ï¸'
    };
    
    // Update placeholder based on selected provider
    function updateMailboxPlaceholder() {
      const provider = document.getElementById('newMailboxProvider').value;
      const emailInput = document.getElementById('newMailboxEmail');
      const passwordHint = document.getElementById('passwordHint');
      
      if (provider === 'gmail') {
        emailInput.placeholder = 'your@gmail.com';
        passwordHint.textContent = 'Gmail: åœ¨Googleè´¦æˆ·å®‰å…¨è®¾ç½®ä¸­ç”Ÿæˆåº”ç”¨ä¸“ç”¨å¯†ç ';
      } else {
        emailInput.placeholder = 'your@yahoo.com';
        passwordHint.textContent = 'Yahoo: åœ¨è´¦æˆ·å®‰å…¨è®¾ç½®ä¸­ç”Ÿæˆåº”ç”¨ä¸“ç”¨å¯†ç ';
      }
    }
    
    // Load and display saved mailboxes
    async function loadMailboxes() {
      const mailboxList = document.getElementById('mailboxList');
      const statusEl = document.getElementById('mailboxListStatus');
      
      try {
        const res = await apiGet('/api/mailboxes');

        if (!res.ok) {
          const error = await res.json();
          throw new Error(error.error || 'Failed to load mailboxes');
        }

        const data = await res.json();
        const mailboxes = data.mailboxes || [];

        if (mailboxes.length === 0) {
          mailboxList.innerHTML = `
            <div class="mailbox-empty">
              <p>ğŸ“­ è¿˜æ²¡æœ‰ä¿å­˜çš„é‚®ç®±</p>
              <p style="font-size:13px; margin-top:5px;">æ·»åŠ é‚®ç®±åå¯ä»¥å¿«é€Ÿè¿æ¥</p>
            </div>
          `;
        } else {
          mailboxList.innerHTML = mailboxes.map(mailbox => {
            const provider = mailbox.provider || 'yahoo';
            const icon = providerIcons[provider] || 'ğŸ“§';
            const providerName = providerNames[provider] || 'Yahoo';
            return `
            <div class="mailbox-item" data-id="${escapeHtml(mailbox.id)}">
              <div class="mailbox-info" onclick="useMailbox('${escapeHtml(mailbox.id)}')">
                <span class="mailbox-icon">${icon}</span>
                <div>
                  <div class="mailbox-email">${escapeHtml(mailbox.email)}</div>
                  <div class="mailbox-date">
                    <span style="background:#e3f2fd; color:#1565c0; padding:1px 6px; border-radius:10px; font-size:10px; margin-right:5px;">${providerName}</span>
                    æ·»åŠ äº ${new Date(mailbox.addedAt).toLocaleDateString()}
                  </div>
                </div>
              </div>
              <div class="mailbox-actions">
                <button class="btn-use" onclick="useMailbox('${escapeHtml(mailbox.id)}')">ä½¿ç”¨</button>
                <button class="btn-edit-rule" onclick="editMailbox('${escapeHtml(mailbox.id)}')" style="background:#17a2b8;">ç¼–è¾‘</button>
                <button class="btn-delete" onclick="deleteMailbox('${escapeHtml(mailbox.id)}', '${escapeHtml(mailbox.email)}')">åˆ é™¤</button>
              </div>
            </div>
          `}).join('');
        }
        
        if (statusEl.textContent) {
          statusEl.textContent = '';
        }
      } catch (e) {
        mailboxList.innerHTML = `<p style="color:#dc3545;">âŒ åŠ è½½å¤±è´¥: ${e.message}</p>`;
      }
    }

    // Save mailbox (add or update)
    async function saveMailboxForm() {
      const email = document.getElementById('newMailboxEmail').value.trim();
      const password = document.getElementById('newMailboxPassword').value;
      const provider = document.getElementById('newMailboxProvider').value;
      const editingId = document.getElementById('editingMailboxId').value;
      const statusEl = document.getElementById('mailboxListStatus');

      if (!email) {
        showStatus('mailboxListStatus', 'è¯·è¾“å…¥é‚®ç®±åœ°å€', 'error');
        return;
      }

      // Basic email validation
      if (!email.includes('@')) {
        showStatus('mailboxListStatus', 'è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€', 'error');
        return;
      }

      // Password required for new mailbox, optional for update
      if (!editingId && !password) {
        showStatus('mailboxListStatus', 'è¯·è¾“å…¥å¯†ç ', 'error');
        return;
      }

      const isEditing = !!editingId;
      showStatus('mailboxListStatus', isEditing ? 'æ­£åœ¨æ›´æ–°é‚®ç®±...' : 'æ­£åœ¨æ·»åŠ é‚®ç®±...', 'info');

      try {
        let res;
        const data = { email, provider };
        if (password) {
          data.password = password;
        }
        
        if (isEditing) {
          res = await apiPut(`/api/mailboxes/${editingId}`, data);
        } else {
          data.password = password; // Password required for new
          res = await apiPost('/api/mailboxes', data);
        }

        if (!res.ok) {
          const error = await res.json();
          throw new Error(error.error || (isEditing ? 'Failed to update mailbox' : 'Failed to add mailbox'));
        }

        // Clear form and reset state
        clearMailboxForm();

        showStatus('mailboxListStatus', isEditing ? 'âœ… é‚®ç®±æ›´æ–°æˆåŠŸ' : 'âœ… é‚®ç®±æ·»åŠ æˆåŠŸ', 'success');
        
        // Reload mailbox list
        await loadMailboxes();
        
        // Clear success message after 3 seconds
        setTimeout(() => {
          const statusEl = document.getElementById('mailboxListStatus');
          if (statusEl.textContent.includes('æˆåŠŸ')) {
            statusEl.textContent = '';
            statusEl.className = '';
          }
        }, 3000);
      } catch (e) {
        showStatus('mailboxListStatus', 'âŒ ' + (isEditing ? 'æ›´æ–°' : 'æ·»åŠ ') + 'å¤±è´¥: ' + e.message, 'error');
      }
    }

    // Edit a mailbox
    async function editMailbox(mailboxId) {
      showStatus('mailboxListStatus', 'æ­£åœ¨åŠ è½½é‚®ç®±ä¿¡æ¯...', 'info');

      try {
        // Get mailbox info
        const listRes = await apiGet('/api/mailboxes');
        if (!listRes.ok) {
          throw new Error('Failed to load mailbox');
        }
        const listData = await listRes.json();
        const mailbox = (listData.mailboxes || []).find(m => m.id === mailboxId);
        
        if (!mailbox) {
          throw new Error('Mailbox not found');
        }

        // Fill form
        document.getElementById('newMailboxEmail').value = mailbox.email;
        document.getElementById('newMailboxProvider').value = mailbox.provider || 'yahoo';
        document.getElementById('newMailboxPassword').value = ''; // Don't show password
        document.getElementById('editingMailboxId').value = mailboxId;
        
        // Update UI
        document.getElementById('mailboxFormTitle').textContent = 'âœï¸ ç¼–è¾‘é‚®ç®±';
        document.getElementById('saveMailboxBtn').textContent = 'æ›´æ–°é‚®ç®±';
        document.getElementById('saveMailboxBtn').style.background = '#17a2b8';
        document.getElementById('cancelMailboxBtn').style.display = 'inline-block';
        document.getElementById('passwordHint').textContent = 'ç•™ç©ºåˆ™ä¿æŒåŸå¯†ç ä¸å˜';
        
        updateMailboxPlaceholder();
        
        showStatus('mailboxListStatus', 'ğŸ“ æ­£åœ¨ç¼–è¾‘é‚®ç®±ï¼Œä¿®æ”¹åç‚¹å‡»"æ›´æ–°é‚®ç®±"ä¿å­˜', 'info');
        
        // Scroll to form
        document.getElementById('savedMailboxesCard').scrollIntoView({ behavior: 'smooth', block: 'center' });
      } catch (e) {
        showStatus('mailboxListStatus', 'âŒ åŠ è½½å¤±è´¥: ' + e.message, 'error');
      }
    }

    // Cancel mailbox edit
    function cancelMailboxEdit() {
      clearMailboxForm();
      showStatus('mailboxListStatus', '', '');
    }

    // Clear mailbox form
    function clearMailboxForm() {
      document.getElementById('newMailboxEmail').value = '';
      document.getElementById('newMailboxPassword').value = '';
      document.getElementById('newMailboxProvider').value = 'yahoo';
      document.getElementById('editingMailboxId').value = '';
      
      document.getElementById('mailboxFormTitle').textContent = 'â• æ·»åŠ æ–°é‚®ç®±';
      document.getElementById('saveMailboxBtn').textContent = 'æ·»åŠ é‚®ç®±';
      document.getElementById('saveMailboxBtn').style.background = '';
      document.getElementById('cancelMailboxBtn').style.display = 'none';
      
      updateMailboxPlaceholder();
    }

    // Legacy function - redirects to new function
    async function addMailbox() {
      await saveMailboxForm();
    }

    // Delete a mailbox
    async function deleteMailbox(mailboxId, email) {
      if (!confirm(`ç¡®å®šè¦åˆ é™¤é‚®ç®± "${email}" å—ï¼Ÿ\n\næ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`)) {
        return;
      }

      showStatus('mailboxListStatus', 'æ­£åœ¨åˆ é™¤...', 'info');

      try {
        const res = await apiDelete(`/api/mailboxes/${mailboxId}`);

        if (!res.ok) {
          const error = await res.json();
          throw new Error(error.error || 'Failed to delete mailbox');
        }

        showStatus('mailboxListStatus', 'âœ… é‚®ç®±å·²åˆ é™¤', 'success');
        
        // Reload mailbox list
        await loadMailboxes();
        
        // Clear success message after 3 seconds
        setTimeout(() => {
          const statusEl = document.getElementById('mailboxListStatus');
          if (statusEl.textContent.includes('åˆ é™¤')) {
            statusEl.textContent = '';
            statusEl.className = '';
          }
        }, 3000);
      } catch (e) {
        showStatus('mailboxListStatus', 'âŒ åˆ é™¤å¤±è´¥: ' + e.message, 'error');
      }
    }

    // Use a saved mailbox (auto-fill credentials)
    async function useMailbox(mailboxId) {
      showStatus('mailboxListStatus', 'æ­£åœ¨åŠ è½½é‚®ç®±ä¿¡æ¯...', 'info');

      try {
        // Get the decrypted password
        const res = await apiGet(`/api/mailboxes/${mailboxId}/password`);

        if (!res.ok) {
          const error = await res.json();
          throw new Error(error.error || 'Failed to get mailbox credentials');
        }

        const data = await res.json();

        // Auto-fill the connection form
        document.getElementById('email').value = data.email;
        document.getElementById('password').value = data.password;

        showStatus('mailboxListStatus', 'âœ… å·²å¡«å……é‚®ç®±ä¿¡æ¯ï¼Œè¯·ç‚¹å‡»"è¿æ¥"æŒ‰é’®', 'success');
        
        // Scroll to connection card
        document.getElementById('connectionCard').scrollIntoView({ behavior: 'smooth' });
        
        // Clear success message after 5 seconds
        setTimeout(() => {
          const statusEl = document.getElementById('mailboxListStatus');
          if (statusEl.textContent.includes('å¡«å……')) {
            statusEl.textContent = '';
            statusEl.className = '';
          }
        }, 5000);
      } catch (e) {
        showStatus('mailboxListStatus', 'âŒ åŠ è½½å¤±è´¥: ' + e.message, 'error');
      }
    }

    // ==================== Navigation Functions ====================
    
    // Current active module
    let currentModule = 'mailbox-management';
    
    // Switch between feature modules
    function switchModule(moduleName) {
      // Update current module
      currentModule = moduleName;
      
      // Hide all modules
      const modules = document.querySelectorAll('.feature-module');
      modules.forEach(module => {
        module.classList.remove('active');
      });
      
      // Show selected module
      const targetModule = document.getElementById('module-' + moduleName);
      if (targetModule) {
        targetModule.classList.add('active');
      }
      
      // Update navigation item highlighting
      const navItems = document.querySelectorAll('.nav-item');
      navItems.forEach(item => {
        item.classList.remove('active');
        if (item.getAttribute('data-module') === moduleName) {
          item.classList.add('active');
        }
      });
      
      // Load pattern history when switching to extraction module
      if (moduleName === 'extraction') {
        loadPatternHistory();
      }
      
      // Initialize email management when switching to that module
      if (moduleName === 'email-management') {
        initEmailManagement();
      }
      
      // Close mobile menu after switching (on mobile devices)
      closeMobileMenu();
    }
    
    // ==================== Mobile Menu Functions ====================
    
    // Toggle mobile menu
    function toggleMobileMenu() {
      const sidebar = document.getElementById('sidebar');
      const overlay = document.getElementById('mobileOverlay');
      const isOpen = sidebar.classList.contains('mobile-open');
      
      if (isOpen) {
        closeMobileMenu();
      } else {
        sidebar.classList.add('mobile-open');
        overlay.classList.add('visible');
      }
    }
    
    // Close mobile menu
    function closeMobileMenu() {
      const sidebar = document.getElementById('sidebar');
      const overlay = document.getElementById('mobileOverlay');
      sidebar.classList.remove('mobile-open');
      overlay.classList.remove('visible');
    }

    // ==================== Email Management Functions ====================
    
    // Email management state
    let emailMgmtState = {
      currentFolder: null,
      folders: [],
      emails: [],
      conversations: [],
      selectedUids: new Set(),
      pagination: {
        page: 1,
        pageSize: 20,
        totalCount: 0,
        totalPages: 0
      },
      searchPattern: '',
      isSearchMode: false,
      sortOrder: 'desc', // 'desc' = newest first, 'asc' = oldest first
      viewMode: 'list' // 'list' or 'conversation'
    };
    
    // Initialize email management module
    function initEmailManagement() {
      const connectionNotice = document.getElementById('emailMgmtConnectionNotice');
      const content = document.getElementById('emailMgmtContent');
      
      if (!sessionId) {
        // Not connected - show notice
        connectionNotice.style.display = 'block';
        content.style.display = 'none';
      } else {
        // Connected - show content and load folders
        connectionNotice.style.display = 'none';
        content.style.display = 'block';
        loadEmailFolders();
      }
    }
    
    // Load email folders
    async function loadEmailFolders() {
      const folderList = document.getElementById('emailFolderList');
      
      if (!sessionId) {
        folderList.innerHTML = '<p style="color:#666; font-size:13px;">è¯·å…ˆè¿æ¥é‚®ç®±</p>';
        return;
      }
      
      try {
        // Fetch fresh folder list from server
        const res = await apiPost('/api/folders', { sessionId });
        if (!res.ok) throw new Error('Failed to load folders');
        
        const data = await res.json();
        let folders = (data.folders || []).map(f => f.name || f);
        
        // Filter out virtual parent folders that can't be selected (like [Gmail])
        const virtualFolders = ['[Gmail]', '[Google Mail]'];
        folders = folders.filter(f => !virtualFolders.includes(f));
        
        if (folders.length === 0) {
          folderList.innerHTML = '<p style="color:#666; font-size:13px;">æ²¡æœ‰æ‰¾åˆ°æ–‡ä»¶å¤¹</p>';
          return;
        }
        
        emailMgmtState.folders = folders;
        
        // Also update the folder select in extraction module
        const folderSelect = document.getElementById('folder');
        if (folderSelect) {
          const currentValue = folderSelect.value;
          folderSelect.innerHTML = folders.map(f => `<option value="${escapeHtml(f)}">${escapeHtml(f)}</option>`).join('');
          if (folders.includes(currentValue)) {
            folderSelect.value = currentValue;
          }
        }
        
        // Render folder list
        folderList.innerHTML = folders.map(folder => {
          const icon = getFolderIcon(folder);
          const displayName = getFolderDisplayName(folder);
          const isActive = emailMgmtState.currentFolder === folder;
          return `
            <div class="folder-item ${isActive ? 'active' : ''}" onclick="selectEmailFolder('${escapeHtml(folder)}')">
              <span class="folder-icon">${icon}</span>
              <span class="folder-name">${escapeHtml(displayName)}</span>
            </div>
          `;
        }).join('');
        
        // Auto-select INBOX if no folder selected
        if (!emailMgmtState.currentFolder && folders.includes('INBOX')) {
          selectEmailFolder('INBOX');
        }
      } catch (e) {
        console.error('Failed to load folders:', e);
        // Fallback to folder select options
        const folderSelect = document.getElementById('folder');
        let folders = Array.from(folderSelect.options).map(opt => opt.value);
        const virtualFolders = ['[Gmail]', '[Google Mail]'];
        folders = folders.filter(f => !virtualFolders.includes(f));
        
        emailMgmtState.folders = folders;
        folderList.innerHTML = folders.map(folder => {
          const icon = getFolderIcon(folder);
          const displayName = getFolderDisplayName(folder);
          const isActive = emailMgmtState.currentFolder === folder;
          return `
            <div class="folder-item ${isActive ? 'active' : ''}" onclick="selectEmailFolder('${escapeHtml(folder)}')">
              <span class="folder-icon">${icon}</span>
              <span class="folder-name">${escapeHtml(displayName)}</span>
            </div>
          `;
        }).join('');
      }
    }
    
    // Get icon for folder name
    function getFolderIcon(folderName) {
      const name = folderName.toLowerCase();
      if (name === 'inbox') return 'ğŸ“¥';
      if (name.includes('sent')) return 'ğŸ“¤';
      if (name.includes('draft')) return 'ğŸ“';
      if (name.includes('trash') || name.includes('deleted')) return 'ğŸ—‘ï¸';
      if (name.includes('spam') || name.includes('junk') || name === 'bulk') return 'âš ï¸';
      if (name.includes('archive')) return 'ğŸ“¦';
      return 'ğŸ“';
    }
    
    // Get display name for folder (translate system folder names)
    function getFolderDisplayName(folderName) {
      const name = folderName.toLowerCase();
      // Yahoo Bulk folder is actually Spam
      if (name === 'bulk') return 'Bulk (åƒåœ¾é‚®ä»¶)';
      return folderName;
    }
    
    // Select a folder and load emails
    async function selectEmailFolder(folder) {
      emailMgmtState.currentFolder = folder;
      emailMgmtState.pagination.page = 1;
      emailMgmtState.selectedUids.clear();
      emailMgmtState.isSearchMode = false;
      emailMgmtState.searchPattern = '';
      document.getElementById('emailSearchPattern').value = '';
      
      // Update folder list UI
      const folderItems = document.querySelectorAll('.folder-item');
      folderItems.forEach(item => {
        item.classList.remove('active');
        if (item.textContent.includes(folder)) {
          item.classList.add('active');
        }
      });
      
      await loadEmailList();
    }
    
    // Load email list for current folder
    async function loadEmailList() {
      // If in conversation view mode, load conversations instead
      if (emailMgmtState.viewMode === 'conversation') {
        await loadConversations();
        return;
      }
      
      const tableBody = document.getElementById('emailTableBody');
      const statusEl = document.getElementById('emailListStatus');
      
      if (!sessionId || !emailMgmtState.currentFolder) {
        tableBody.innerHTML = '<tr><td colspan="4" style="text-align:center; padding:30px; color:#666;">é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶å¤¹ä»¥æŸ¥çœ‹é‚®ä»¶</td></tr>';
        return;
      }
      
      statusEl.textContent = 'åŠ è½½ä¸­...';
      tableBody.innerHTML = '<tr><td colspan="4" style="text-align:center; padding:30px; color:#666;">â³ æ­£åœ¨åŠ è½½é‚®ä»¶...</td></tr>';
      
      try {
        const endpoint = emailMgmtState.isSearchMode ? '/api/emails/search' : '/api/emails/list';
        const body = {
          sessionId,
          folder: emailMgmtState.currentFolder,
          page: emailMgmtState.pagination.page,
          pageSize: emailMgmtState.pagination.pageSize,
          sortOrder: emailMgmtState.sortOrder
        };
        
        if (emailMgmtState.isSearchMode && emailMgmtState.searchPattern) {
          body.subjectPattern = emailMgmtState.searchPattern;
        }
        
        const res = await apiPost(endpoint, body);
        
        if (!res.ok) {
          const error = await res.json();
          throw new Error(error.error || 'Failed to load emails');
        }
        
        const data = await res.json();
        emailMgmtState.emails = data.emails || [];
        emailMgmtState.pagination = data.pagination || {
          page: 1,
          pageSize: 20,
          totalCount: 0,
          totalPages: 0
        };
        
        renderEmailList();
        updatePaginationUI();
        updateSelectedCount();
        
        const searchInfo = emailMgmtState.isSearchMode ? ` (æœç´¢: "${emailMgmtState.searchPattern}")` : '';
        statusEl.textContent = `å…± ${emailMgmtState.pagination.totalCount} å°é‚®ä»¶${searchInfo}`;
      } catch (e) {
        tableBody.innerHTML = `<tr><td colspan="4" style="text-align:center; padding:30px; color:#dc3545;">âŒ åŠ è½½å¤±è´¥: ${escapeHtml(e.message)}</td></tr>`;
        statusEl.textContent = 'åŠ è½½å¤±è´¥';
      }
    }
    
    // Render email list table
    function renderEmailList() {
      const tableBody = document.getElementById('emailTableBody');
      const emails = emailMgmtState.emails;
      
      // Show table, hide conversation container
      document.getElementById('emailTable').style.display = 'table';
      const convContainer = document.getElementById('conversationContainer');
      if (convContainer) convContainer.style.display = 'none';
      
      if (emails.length === 0) {
        const message = emailMgmtState.isSearchMode ? 'æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„é‚®ä»¶' : 'æ­¤æ–‡ä»¶å¤¹ä¸ºç©º';
        tableBody.innerHTML = `<tr><td colspan="4" style="text-align:center; padding:30px; color:#666;">${message}</td></tr>`;
        return;
      }
      
      tableBody.innerHTML = emails.map(email => {
        const isSelected = emailMgmtState.selectedUids.has(email.uid);
        const date = new Date(email.date);
        const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        
        return `
          <tr class="email-row ${isSelected ? 'selected' : ''}" data-uid="${email.uid}" onclick="viewEmailContent(${email.uid}, '${escapeHtml(email.subject).replace(/'/g, "\\'")}', '${escapeHtml(email.sender).replace(/'/g, "\\'")}', '${escapeHtml(email.recipient || '').replace(/'/g, "\\'")}', '${escapeHtml(dateStr).replace(/'/g, "\\'")}')">
            <td style="text-align:center;">
              <input type="checkbox" class="email-checkbox" ${isSelected ? 'checked' : ''} 
                     onchange="toggleEmailSelection(${email.uid}, this.checked)" 
                     onclick="event.stopPropagation()">
            </td>
            <td class="email-date">${escapeHtml(dateStr)}</td>
            <td class="email-sender" title="${escapeHtml(email.sender)}">${escapeHtml(email.sender)}</td>
            <td class="email-subject" title="${escapeHtml(email.subject)}">${escapeHtml(email.subject || '(æ— ä¸»é¢˜)')}</td>
          </tr>
        `;
      }).join('');
    }
    
    // ==================== Conversation View Functions ====================
    
    // Switch between list and conversation view modes
    function switchEmailViewMode(mode) {
      emailMgmtState.viewMode = mode;
      emailMgmtState.pagination.page = 1;
      emailMgmtState.selectedUids.clear();
      document.getElementById('selectAllEmails').checked = false;
      
      // Update button styles
      const listBtn = document.getElementById('btnListView');
      const convBtn = document.getElementById('btnConversationView');
      
      if (mode === 'list') {
        listBtn.style.background = '#6001d2';
        listBtn.style.color = 'white';
        convBtn.style.background = '#f0f0f0';
        convBtn.style.color = '#333';
      } else {
        listBtn.style.background = '#f0f0f0';
        listBtn.style.color = '#333';
        convBtn.style.background = '#6001d2';
        convBtn.style.color = 'white';
      }
      
      // Reload data
      loadEmailList();
    }
    
    // Load conversations for current folder
    async function loadConversations() {
      const tableBody = document.getElementById('emailTableBody');
      const statusEl = document.getElementById('emailListStatus');
      
      if (!sessionId || !emailMgmtState.currentFolder) {
        showConversationContainer('<div class="conversation-empty">é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶å¤¹ä»¥æŸ¥çœ‹é‚®ä»¶</div>');
        return;
      }
      
      statusEl.textContent = 'åŠ è½½ä¼šè¯ä¸­...';
      showConversationContainer('<div class="conversation-empty">â³ æ­£åœ¨åŠ è½½ä¼šè¯...</div>');
      
      try {
        const res = await apiPost('/api/emails/conversations', {
          sessionId,
          folder: emailMgmtState.currentFolder,
          page: emailMgmtState.pagination.page,
          pageSize: emailMgmtState.pagination.pageSize,
          sortOrder: emailMgmtState.sortOrder
        });
        
        if (!res.ok) {
          const error = await res.json();
          throw new Error(error.error || 'Failed to load conversations');
        }
        
        const data = await res.json();
        console.log('[Conversations] API response:', data);
        
        emailMgmtState.conversations = data.conversations || [];
        emailMgmtState.pagination = data.pagination || {
          page: 1,
          pageSize: 20,
          totalCount: 0,
          totalPages: 0
        };
        
        renderConversations();
        updatePaginationUI();
        updateSelectedCount();
        
        statusEl.textContent = `å…± ${emailMgmtState.pagination.totalCount} ä¸ªä¼šè¯`;
      } catch (e) {
        console.error('[Conversations] Error:', e);
        showConversationContainer(`<div class="conversation-empty" style="color:#dc3545;">âŒ åŠ è½½å¤±è´¥: ${escapeHtml(e.message)}</div>`);
        statusEl.textContent = 'åŠ è½½å¤±è´¥';
      }
    }
    
    // Show conversation container and hide table
    function showConversationContainer(content) {
      // Hide table
      document.getElementById('emailTable').style.display = 'none';
      
      // Get or create conversation container
      let convContainer = document.getElementById('conversationContainer');
      if (!convContainer) {
        convContainer = document.createElement('div');
        convContainer.id = 'conversationContainer';
        convContainer.style.marginTop = '10px';
        document.getElementById('emailTable').parentNode.appendChild(convContainer);
      }
      
      convContainer.style.display = 'block';
      convContainer.innerHTML = content;
    }
    
    // Render conversations
    function renderConversations() {
      const conversations = emailMgmtState.conversations || [];
      
      console.log('[Conversations] Rendering', conversations.length, 'conversations');
      
      if (!conversations || conversations.length === 0) {
        showConversationContainer('<div class="conversation-empty">æ­¤æ–‡ä»¶å¤¹ä¸ºç©º</div>');
        return;
      }
      
      try {
        const html = conversations.map((conv, index) => {
          if (!conv) return '';
          
          const latestDate = conv.latestDate ? new Date(conv.latestDate) : new Date();
          const dateStr = latestDate.toLocaleDateString() + ' ' + latestDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
          const participantsList = conv.participants || [];
          const participants = participantsList.length > 0 
            ? participantsList.slice(0, 3).join(', ') + (participantsList.length > 3 ? '...' : '')
            : '(æœªçŸ¥)';
          
          // Check if any email in this conversation is selected
          const convEmails = conv.emails || [];
          const convUids = convEmails.filter(e => e).map(e => e.uid);
          const selectedInConv = convUids.filter(uid => emailMgmtState.selectedUids.has(uid)).length;
          const allSelected = convUids.length > 0 && selectedInConv === convUids.length;
          
          // Build emails list HTML
          const emailsHtml = convEmails.map((email, emailIndex) => {
            if (!email) return '';
            
            const emailDate = email.date ? new Date(email.date) : new Date();
            const emailDateStr = emailDate.toLocaleDateString() + ' ' + emailDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            const isSelected = emailMgmtState.selectedUids.has(email.uid);
            const isFirst = emailIndex === 0;
            const emailSubject = email.subject || '(æ— ä¸»é¢˜)';
            const emailSender = email.sender || '(æœªçŸ¥å‘ä»¶äºº)';
            
            // Escape for HTML attribute (onclick)
            const safeSubject = escapeHtml(emailSubject).replace(/'/g, "\\'").replace(/"/g, '&quot;');
            const safeSender = escapeHtml(emailSender).replace(/'/g, "\\'").replace(/"/g, '&quot;');
            const safeRecipient = escapeHtml(email.recipient || '').replace(/'/g, "\\'").replace(/"/g, '&quot;');
            const safeDateStr = escapeHtml(emailDateStr).replace(/'/g, "\\'").replace(/"/g, '&quot;');
            
            return `
              <div class="conversation-email-item ${isFirst ? 'first-email' : ''}" 
                   data-uid="${email.uid}"
                   data-subject="${safeSubject}"
                   data-sender="${safeSender}"
                   data-recipient="${safeRecipient}"
                   data-date="${safeDateStr}"
                   onclick="viewConversationEmail(this)">
                <input type="checkbox" class="conversation-email-checkbox" ${isSelected ? 'checked' : ''} 
                       onchange="toggleEmailSelection(${email.uid}, this.checked); event.stopPropagation();" 
                       onclick="event.stopPropagation()">
                <div class="conversation-email-info">
                  <div class="conversation-email-subject">${isFirst ? 'ğŸ“Œ ' : ''}${escapeHtml(emailSubject)}</div>
                  <div class="conversation-email-sender">${escapeHtml(emailSender)}</div>
                </div>
                <div class="conversation-email-date">${escapeHtml(emailDateStr)}</div>
              </div>
            `;
          }).join('');
          
          const convSubject = conv.subject || '(æ— ä¸»é¢˜)';
          const emailCount = conv.emailCount || convEmails.length || 0;
          
          return `
            <div class="conversation-item" data-conv-index="${index}">
              <div class="conversation-header" onclick="toggleConversation(${index}, event)">
                <input type="checkbox" class="conversation-checkbox" ${allSelected ? 'checked' : ''} 
                       onchange="toggleConversationSelection(${index}, this.checked)" 
                       onclick="event.stopPropagation()">
                <span class="conversation-expand-icon">â–¶</span>
                <div class="conversation-info">
                  <div class="conversation-subject">${escapeHtml(convSubject)}</div>
                  <div class="conversation-meta">
                    <span class="conversation-count">${emailCount} å°</span>
                    <span class="conversation-participants" title="${escapeHtml(participantsList.join(', '))}">${escapeHtml(participants)}</span>
                  </div>
                </div>
                <div class="conversation-date">${escapeHtml(dateStr)}</div>
              </div>
              <div class="conversation-emails">
                ${emailsHtml}
              </div>
            </div>
          `;
        }).join('');
        
        showConversationContainer(html);
      } catch (e) {
        console.error('[Conversations] Render error:', e);
        showConversationContainer(`<div class="conversation-empty" style="color:#dc3545;">âŒ æ¸²æŸ“å¤±è´¥: ${escapeHtml(e.message)}</div>`);
      }
    }
    
    // Toggle conversation expansion
    function toggleConversation(index, event) {
      // Don't toggle if clicking on checkbox
      if (event.target.type === 'checkbox') return;
      
      const convItem = document.querySelector(`.conversation-item[data-conv-index="${index}"]`);
      if (convItem) {
        const wasExpanded = convItem.classList.contains('expanded');
        convItem.classList.toggle('expanded');
        
        // If expanding and clicking on the conversation header (not on a specific email),
        // automatically view the first email's content
        if (!wasExpanded) {
          const conv = emailMgmtState.conversations[index];
          if (conv && conv.firstEmail) {
            const firstEmail = conv.firstEmail;
            const emailDate = new Date(firstEmail.date);
            const emailDateStr = emailDate.toLocaleDateString() + ' ' + emailDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            viewEmailContent(
              firstEmail.uid, 
              firstEmail.subject, 
              firstEmail.sender, 
              firstEmail.recipient || '', 
              emailDateStr
            );
          }
        }
      }
    }
    
    // Toggle selection for all emails in a conversation
    function toggleConversationSelection(index, isSelected) {
      const conv = emailMgmtState.conversations[index];
      if (!conv) return;
      
      conv.emails.forEach(email => {
        if (isSelected) {
          emailMgmtState.selectedUids.add(email.uid);
        } else {
          emailMgmtState.selectedUids.delete(email.uid);
        }
      });
      
      // Update checkboxes in the conversation
      const convItem = document.querySelector(`.conversation-item[data-conv-index="${index}"]`);
      if (convItem) {
        const checkboxes = convItem.querySelectorAll('.conversation-email-checkbox');
        checkboxes.forEach(cb => {
          cb.checked = isSelected;
        });
      }
      
      updateSelectedCount();
      updateSelectAllCheckbox();
    }
    
    // View email content from conversation (using data attributes)
    function viewConversationEmail(element) {
      const uid = parseInt(element.dataset.uid);
      const subject = element.dataset.subject || '(æ— ä¸»é¢˜)';
      const sender = element.dataset.sender || '(æœªçŸ¥å‘ä»¶äºº)';
      const recipient = element.dataset.recipient || '';
      const dateStr = element.dataset.date || '';
      
      viewEmailContent(uid, subject, sender, recipient, dateStr);
    }
    
    // Toggle email selection
    function toggleEmailSelection(uid, isSelected) {
      if (isSelected) {
        emailMgmtState.selectedUids.add(uid);
      } else {
        emailMgmtState.selectedUids.delete(uid);
      }
      
      // Update row styling
      const row = document.querySelector(`tr[data-uid="${uid}"]`);
      if (row) {
        row.classList.toggle('selected', isSelected);
      }
      
      updateSelectedCount();
      updateSelectAllCheckbox();
    }
    
    // Toggle select all emails
    function toggleSelectAllEmails() {
      const selectAll = document.getElementById('selectAllEmails');
      const isChecked = selectAll.checked;
      
      if (emailMgmtState.viewMode === 'conversation') {
        // In conversation view, select all emails from all conversations
        emailMgmtState.conversations.forEach(conv => {
          conv.emails.forEach(email => {
            if (isChecked) {
              emailMgmtState.selectedUids.add(email.uid);
            } else {
              emailMgmtState.selectedUids.delete(email.uid);
            }
          });
        });
        
        // Update all checkboxes in conversations
        const convCheckboxes = document.querySelectorAll('.conversation-checkbox');
        convCheckboxes.forEach(cb => {
          cb.checked = isChecked;
        });
        
        const emailCheckboxes = document.querySelectorAll('.conversation-email-checkbox');
        emailCheckboxes.forEach(cb => {
          cb.checked = isChecked;
        });
      } else {
        // In list view
        emailMgmtState.emails.forEach(email => {
          if (isChecked) {
            emailMgmtState.selectedUids.add(email.uid);
          } else {
            emailMgmtState.selectedUids.delete(email.uid);
          }
        });
        
        // Update all checkboxes
        const checkboxes = document.querySelectorAll('.email-checkbox');
        checkboxes.forEach(cb => {
          cb.checked = isChecked;
        });
        
        // Update row styling
        const rows = document.querySelectorAll('.email-row');
        rows.forEach(row => {
          row.classList.toggle('selected', isChecked);
        });
      }
      
      updateSelectedCount();
    }
    
    // Update select all checkbox state
    function updateSelectAllCheckbox() {
      const selectAll = document.getElementById('selectAllEmails');
      const totalOnPage = emailMgmtState.emails.length;
      const selectedOnPage = emailMgmtState.emails.filter(e => emailMgmtState.selectedUids.has(e.uid)).length;
      
      selectAll.checked = totalOnPage > 0 && selectedOnPage === totalOnPage;
      selectAll.indeterminate = selectedOnPage > 0 && selectedOnPage < totalOnPage;
    }
    
    // Update selected count display
    function updateSelectedCount() {
      const count = emailMgmtState.selectedUids.size;
      document.getElementById('selectedCount').textContent = count;
      document.getElementById('btnBatchDelete').disabled = count === 0;
      document.getElementById('btnMoveEmails').disabled = count === 0;
    }
    
    // Update pagination UI
    function updatePaginationUI() {
      const { page, pageSize, totalCount, totalPages } = emailMgmtState.pagination;
      
      const start = totalCount === 0 ? 0 : (page - 1) * pageSize + 1;
      const end = Math.min(page * pageSize, totalCount);
      
      document.getElementById('paginationInfo').textContent = 
        totalCount === 0 ? 'æ²¡æœ‰é‚®ä»¶' : `æ˜¾ç¤º ${start}-${end} / å…± ${totalCount} å°`;
      document.getElementById('pageIndicator').textContent = `ç¬¬ ${page} / ${totalPages || 1} é¡µ`;
      
      document.getElementById('btnPrevPage').disabled = page <= 1;
      document.getElementById('btnNextPage').disabled = page >= totalPages;
      
      document.getElementById('pageSizeSelect').value = pageSize;
    }
    
    // Go to email page
    async function goToEmailPage(direction) {
      if (direction === 'prev' && emailMgmtState.pagination.page > 1) {
        emailMgmtState.pagination.page--;
      } else if (direction === 'next' && emailMgmtState.pagination.page < emailMgmtState.pagination.totalPages) {
        emailMgmtState.pagination.page++;
      }
      
      emailMgmtState.selectedUids.clear();
      document.getElementById('selectAllEmails').checked = false;
      
      await loadEmailList();
    }
    
    // Change page size
    async function changePageSize() {
      const newSize = parseInt(document.getElementById('pageSizeSelect').value);
      emailMgmtState.pagination.pageSize = newSize;
      emailMgmtState.pagination.page = 1;
      emailMgmtState.selectedUids.clear();
      document.getElementById('selectAllEmails').checked = false;
      
      await loadEmailList();
    }
    
    // Search emails by subject pattern
    async function searchEmails() {
      const pattern = document.getElementById('emailSearchPattern').value.trim();
      
      if (!pattern) {
        clearEmailSearch();
        return;
      }
      
      emailMgmtState.searchPattern = pattern;
      emailMgmtState.isSearchMode = true;
      emailMgmtState.pagination.page = 1;
      emailMgmtState.selectedUids.clear();
      document.getElementById('selectAllEmails').checked = false;
      
      await loadEmailList();
    }
    
    // Clear email search
    async function clearEmailSearch() {
      document.getElementById('emailSearchPattern').value = '';
      emailMgmtState.searchPattern = '';
      emailMgmtState.isSearchMode = false;
      emailMgmtState.pagination.page = 1;
      emailMgmtState.selectedUids.clear();
      document.getElementById('selectAllEmails').checked = false;
      
      await loadEmailList();
    }
    
    // Refresh email list
    async function refreshEmailList() {
      emailMgmtState.selectedUids.clear();
      document.getElementById('selectAllEmails').checked = false;
      await loadEmailList();
    }
    
    // Batch delete selected emails
    async function batchDeleteSelectedEmails() {
      const uids = Array.from(emailMgmtState.selectedUids);
      
      if (uids.length === 0) {
        alert('è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„é‚®ä»¶');
        return;
      }
      
      if (!confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${uids.length} å°é‚®ä»¶å—ï¼Ÿ\n\né‚®ä»¶å°†è¢«ç§»è‡³å›æ”¶ç«™ã€‚`)) {
        return;
      }
      
      const statusEl = document.getElementById('emailListStatus');
      statusEl.textContent = 'æ­£åœ¨åˆ é™¤...';
      
      try {
        const res = await apiPost('/api/emails/batch-delete', {
          sessionId,
          folder: emailMgmtState.currentFolder,
          uids
        });
        
        if (!res.ok) {
          const error = await res.json();
          throw new Error(error.error || 'Failed to delete emails');
        }
        
        const data = await res.json();
        
        statusEl.textContent = `âœ… ${data.message}`;
        
        // Clear selection and refresh
        emailMgmtState.selectedUids.clear();
        document.getElementById('selectAllEmails').checked = false;
        
        // Refresh email list
        await loadEmailList();
        
        // Clear success message after 3 seconds
        setTimeout(() => {
          if (statusEl.textContent.includes('æˆåŠŸ')) {
            statusEl.textContent = `å…± ${emailMgmtState.pagination.totalCount} å°é‚®ä»¶`;
          }
        }, 3000);
      } catch (e) {
        statusEl.textContent = `âŒ åˆ é™¤å¤±è´¥: ${e.message}`;
      }
    }
    
    // ==================== Folder Management Functions ====================
    
    // System folders that cannot be deleted or renamed
    const PROTECTED_FOLDERS = [
      'INBOX', 'Inbox', 'inbox',
      'Sent', 'SENT', 'Sent Messages', 'Sent Mail',
      'Drafts', 'DRAFTS', 'Draft',
      'Trash', 'TRASH', 'Deleted', 'Deleted Messages', 'Deleted Items',
      'Spam', 'SPAM', 'Junk', 'Bulk', 'Bulk Mail',
      'Archive', 'ARCHIVE', 'Archives',
      '[Gmail]', '[Gmail]/All Mail', '[Gmail]/Drafts', '[Gmail]/Important',
      '[Gmail]/Sent Mail', '[Gmail]/Spam', '[Gmail]/Starred', '[Gmail]/Trash'
    ];
    
    function isProtectedFolder(folderName) {
      const normalized = folderName.toLowerCase();
      return PROTECTED_FOLDERS.some(f => f.toLowerCase() === normalized || 
        normalized.startsWith('[gmail]'));
    }
    
    // Show folder manager modal
    async function showFolderManager() {
      const modal = document.getElementById('folderManagerModal');
      modal.classList.add('visible');
      document.getElementById('newFolderName').value = '';
      await loadFolderManagerList();
    }
    
    // Close folder manager modal
    function closeFolderManager(event) {
      if (event && event.target !== event.currentTarget) return;
      document.getElementById('folderManagerModal').classList.remove('visible');
    }
    
    // Load folder list for manager
    async function loadFolderManagerList() {
      const listEl = document.getElementById('folderManagerList');
      listEl.innerHTML = '<div style="text-align:center; color:#999; padding:20px;">åŠ è½½ä¸­...</div>';
      
      try {
        const res = await apiPost('/api/folders', { sessionId });
        if (!res.ok) throw new Error('Failed to load folders');
        
        const data = await res.json();
        const folders = data.folders || [];
        
        if (folders.length === 0) {
          listEl.innerHTML = '<div style="text-align:center; color:#999; padding:20px;">æ²¡æœ‰æ–‡ä»¶å¤¹</div>';
          return;
        }
        
        let html = '';
        folders.forEach(folder => {
          const isProtected = isProtectedFolder(folder.name);
          const displayName = folder.displayName || folder.name;
          
          html += `
            <div style="display:flex; align-items:center; justify-content:space-between; padding:10px; border:1px solid #e0e0e0; border-radius:4px; margin-bottom:8px; background:${isProtected ? '#f9f9f9' : 'white'};">
              <div style="display:flex; align-items:center; gap:8px; flex:1; min-width:0;">
                <span style="font-size:16px;">ğŸ“</span>
                <span style="overflow:hidden; text-overflow:ellipsis; white-space:nowrap;" title="${escapeHtml(folder.name)}">${escapeHtml(displayName)}</span>
                ${isProtected ? '<span style="font-size:10px; background:#e0e0e0; padding:2px 6px; border-radius:10px; color:#666;">ç³»ç»Ÿ</span>' : ''}
              </div>
              <div style="display:flex; gap:6px; flex-shrink:0;">
                ${!isProtected ? `
                  <button onclick="showRenameFolderModal('${escapeHtml(folder.name)}')" style="padding:4px 8px; font-size:12px; background:#17a2b8;">âœï¸</button>
                  <button onclick="deleteFolder('${escapeHtml(folder.name)}')" class="btn-danger" style="padding:4px 8px; font-size:12px;">ğŸ—‘ï¸</button>
                ` : ''}
              </div>
            </div>
          `;
        });
        
        listEl.innerHTML = html;
      } catch (e) {
        listEl.innerHTML = `<div style="text-align:center; color:#dc3545; padding:20px;">åŠ è½½å¤±è´¥: ${e.message}</div>`;
      }
    }
    
    // Create new folder
    async function createFolder() {
      const nameInput = document.getElementById('newFolderName');
      const folderName = nameInput.value.trim();
      
      if (!folderName) {
        alert('è¯·è¾“å…¥æ–‡ä»¶å¤¹åç§°');
        return;
      }
      
      try {
        const res = await apiPost('/api/folders/create', { sessionId, folderName });
        const data = await res.json();
        
        if (data.error) {
          alert('åˆ›å»ºå¤±è´¥: ' + data.error);
          return;
        }
        
        nameInput.value = '';
        await loadFolderManagerList();
        await loadEmailFolders(); // Refresh sidebar folder list
        alert('âœ… æ–‡ä»¶å¤¹åˆ›å»ºæˆåŠŸ');
      } catch (e) {
        alert('åˆ›å»ºå¤±è´¥: ' + e.message);
      }
    }
    
    // Delete folder
    async function deleteFolder(folderName) {
      if (isProtectedFolder(folderName)) {
        alert('ç³»ç»Ÿæ–‡ä»¶å¤¹ä¸èƒ½åˆ é™¤');
        return;
      }
      
      if (!confirm(`ç¡®å®šè¦åˆ é™¤æ–‡ä»¶å¤¹ "${folderName}" å—ï¼Ÿ\n\nâš ï¸ æ–‡ä»¶å¤¹ä¸­çš„é‚®ä»¶ä¹Ÿä¼šè¢«åˆ é™¤ï¼`)) {
        return;
      }
      
      try {
        const res = await apiPost('/api/folders/delete', { sessionId, folderName });
        const data = await res.json();
        
        if (data.error) {
          alert('åˆ é™¤å¤±è´¥: ' + data.error);
          return;
        }
        
        await loadFolderManagerList();
        await loadEmailFolders(); // Refresh sidebar folder list
        alert('âœ… æ–‡ä»¶å¤¹åˆ é™¤æˆåŠŸ');
      } catch (e) {
        alert('åˆ é™¤å¤±è´¥: ' + e.message);
      }
    }
    
    // Show rename folder modal
    function showRenameFolderModal(folderName) {
      document.getElementById('oldFolderName').value = folderName;
      document.getElementById('oldFolderNameDisplay').textContent = folderName;
      document.getElementById('newFolderNameInput').value = '';
      document.getElementById('renameFolderModal').classList.add('visible');
    }
    
    // Close rename folder modal
    function closeRenameFolderModal(event) {
      if (event && event.target !== event.currentTarget) return;
      document.getElementById('renameFolderModal').classList.remove('visible');
    }
    
    // Confirm rename folder
    async function confirmRenameFolder() {
      const oldName = document.getElementById('oldFolderName').value;
      const newName = document.getElementById('newFolderNameInput').value.trim();
      
      if (!newName) {
        alert('è¯·è¾“å…¥æ–°åç§°');
        return;
      }
      
      if (oldName === newName) {
        alert('æ–°åç§°ä¸åŸåç§°ç›¸åŒ');
        return;
      }
      
      try {
        const res = await apiPost('/api/folders/rename', { sessionId, oldName, newName });
        const data = await res.json();
        
        if (data.error) {
          alert('é‡å‘½åå¤±è´¥: ' + data.error);
          return;
        }
        
        closeRenameFolderModal();
        await loadFolderManagerList();
        await loadEmailFolders(); // Refresh sidebar folder list
        alert('âœ… æ–‡ä»¶å¤¹é‡å‘½åæˆåŠŸ');
      } catch (e) {
        alert('é‡å‘½åå¤±è´¥: ' + e.message);
      }
    }
    
    // ==================== Move Emails Functions ====================
    
    // Show move emails modal
    async function showMoveEmailsModal() {
      const count = emailMgmtState.selectedUids.size;
      if (count === 0) {
        alert('è¯·å…ˆé€‰æ‹©è¦ç§»åŠ¨çš„é‚®ä»¶');
        return;
      }
      
      document.getElementById('moveEmailCount').textContent = count;
      
      // Load folder options
      const selectEl = document.getElementById('moveTargetFolder');
      selectEl.innerHTML = '<option value="">-- åŠ è½½ä¸­... --</option>';
      
      document.getElementById('moveEmailsModal').classList.add('visible');
      
      try {
        const res = await apiPost('/api/folders', { sessionId });
        if (!res.ok) throw new Error('Failed to load folders');
        
        const data = await res.json();
        const folders = data.folders || [];
        
        let html = '<option value="">-- é€‰æ‹©ç›®æ ‡æ–‡ä»¶å¤¹ --</option>';
        folders.forEach(folder => {
          // Skip current folder and [Gmail] virtual folder
          if (folder.name === emailMgmtState.currentFolder || folder.name === '[Gmail]') return;
          const displayName = folder.displayName || folder.name;
          html += `<option value="${escapeHtml(folder.name)}">${escapeHtml(displayName)}</option>`;
        });
        
        selectEl.innerHTML = html;
      } catch (e) {
        selectEl.innerHTML = '<option value="">-- åŠ è½½å¤±è´¥ --</option>';
      }
    }
    
    // Close move emails modal
    function closeMoveEmailsModal(event) {
      if (event && event.target !== event.currentTarget) return;
      document.getElementById('moveEmailsModal').classList.remove('visible');
    }
    
    // Move selected emails to target folder
    async function moveSelectedEmails() {
      const targetFolder = document.getElementById('moveTargetFolder').value;
      if (!targetFolder) {
        alert('è¯·é€‰æ‹©ç›®æ ‡æ–‡ä»¶å¤¹');
        return;
      }
      
      const uids = Array.from(emailMgmtState.selectedUids);
      if (uids.length === 0) {
        alert('æ²¡æœ‰é€‰ä¸­çš„é‚®ä»¶');
        return;
      }
      
      const btnConfirm = document.getElementById('btnConfirmMove');
      btnConfirm.disabled = true;
      btnConfirm.textContent = 'ç§»åŠ¨ä¸­...';
      
      try {
        const res = await apiPost('/api/emails/move', {
          sessionId,
          sourceFolder: emailMgmtState.currentFolder,
          targetFolder,
          uids
        });
        
        const data = await res.json();
        
        if (data.error) {
          alert('ç§»åŠ¨å¤±è´¥: ' + data.error);
          return;
        }
        
        closeMoveEmailsModal();
        
        // Clear selection and refresh
        emailMgmtState.selectedUids.clear();
        document.getElementById('selectAllEmails').checked = false;
        updateSelectedCount();
        
        await loadEmailList();
        
        const statusEl = document.getElementById('emailListStatus');
        statusEl.textContent = `âœ… ${data.message}`;
        
        setTimeout(() => {
          if (statusEl.textContent.includes('æˆåŠŸ') || statusEl.textContent.includes('ç§»åŠ¨')) {
            statusEl.textContent = `å…± ${emailMgmtState.pagination.totalCount} å°é‚®ä»¶`;
          }
        }, 3000);
      } catch (e) {
        alert('ç§»åŠ¨å¤±è´¥: ' + e.message);
      } finally {
        btnConfirm.disabled = false;
        btnConfirm.textContent = 'ç¡®è®¤ç§»åŠ¨';
      }
    }
    
    // Empty trash from email management module
    async function emptyTrashFromMgmt() {
      if (!confirm('âš ï¸ è­¦å‘Šï¼šè¿™å°†æ°¸ä¹…åˆ é™¤å›æ”¶ç«™ä¸­çš„æ‰€æœ‰é‚®ä»¶ï¼\n\næ­¤æ“ä½œä¸å¯æ’¤é”€ï¼\n\nç¡®å®šè¦ç»§ç»­å—ï¼Ÿ')) {
        return;
      }
      
      const statusEl = document.getElementById('emailListStatus');
      statusEl.textContent = 'æ­£åœ¨æ¸…ç©ºå›æ”¶ç«™...';
      
      try {
        const res = await apiPost('/api/empty-trash', { sessionId });
        
        const data = await res.json();
        
        if (data.error) {
          statusEl.textContent = `âŒ æ¸…ç©ºå¤±è´¥: ${data.error}`;
        } else {
          statusEl.textContent = `âœ… ${data.message}`;
          
          // Refresh if currently viewing trash
          const currentFolder = emailMgmtState.currentFolder?.toLowerCase() || '';
          if (currentFolder.includes('trash') || currentFolder.includes('deleted')) {
            await loadEmailList();
          }
          
          // Clear success message after 3 seconds
          setTimeout(() => {
            if (statusEl.textContent.includes('æˆåŠŸ') || statusEl.textContent.includes('æ¸…ç©º')) {
              statusEl.textContent = `å…± ${emailMgmtState.pagination.totalCount} å°é‚®ä»¶`;
            }
          }, 3000);
        }
      } catch (e) {
        statusEl.textContent = `âŒ æ¸…ç©ºå¤±è´¥: ${e.message}`;
      }
    }
    
    // Change email sort order
    async function changeEmailSortOrder() {
      const newOrder = document.getElementById('emailSortOrder').value;
      emailMgmtState.sortOrder = newOrder;
      emailMgmtState.pagination.page = 1;
      emailMgmtState.selectedUids.clear();
      document.getElementById('selectAllEmails').checked = false;
      
      await loadEmailList();
    }
    
    // View email content in modal
    async function viewEmailContent(uid, subject, sender, recipient, dateStr) {
      const modal = document.getElementById('emailModal');
      const modalSubject = document.getElementById('emailModalSubject');
      const modalFrom = document.getElementById('emailModalFrom');
      const modalTo = document.getElementById('emailModalTo');
      const modalDate = document.getElementById('emailModalDate');
      const modalBody = document.getElementById('emailModalBody');
      
      // Set header info
      modalSubject.textContent = subject || '(æ— ä¸»é¢˜)';
      modalFrom.textContent = sender || '(æœªçŸ¥å‘ä»¶äºº)';
      modalTo.textContent = recipient || '(æœªçŸ¥æ”¶ä»¶äºº)';
      modalDate.textContent = dateStr || '';
      
      // Show modal with loading state
      modalBody.innerHTML = '<div class="email-modal-loading">â³ æ­£åœ¨åŠ è½½é‚®ä»¶å†…å®¹...</div>';
      modal.classList.add('visible');
      
      try {
        const res = await apiPost('/api/emails/content', {
          sessionId,
          folder: emailMgmtState.currentFolder,
          uid
        });
        
        if (!res.ok) {
          const error = await res.json();
          throw new Error(error.error || 'Failed to load email content');
        }
        
        const data = await res.json();
        
        if (data.content) {
          // Check if content is HTML
          if (data.isHtml) {
            // Create a sandboxed iframe for HTML content
            modalBody.innerHTML = `
              <iframe 
                srcdoc="${escapeHtml(data.content)}" 
                style="width:100%; height:400px; border:1px solid #e0e0e0; border-radius:4px;"
                sandbox="allow-same-origin"
              ></iframe>
              <div style="margin-top:10px;">
                <button class="btn-secondary" onclick="toggleEmailRawContent()" style="font-size:12px; padding:6px 12px;">
                  æŸ¥çœ‹åŸå§‹å†…å®¹
                </button>
              </div>
              <pre id="emailRawContent" style="display:none; margin-top:10px; padding:10px; background:#f5f5f5; border-radius:4px; font-size:12px; max-height:300px; overflow:auto;">${escapeHtml(data.rawContent || data.content)}</pre>
            `;
          } else {
            // Plain text content
            modalBody.innerHTML = `<pre>${escapeHtml(data.content)}</pre>`;
          }
        } else {
          modalBody.innerHTML = '<div style="text-align:center; color:#666; padding:20px;">é‚®ä»¶å†…å®¹ä¸ºç©º</div>';
        }
      } catch (e) {
        modalBody.innerHTML = `<div style="text-align:center; color:#dc3545; padding:20px;">âŒ åŠ è½½å¤±è´¥: ${escapeHtml(e.message)}</div>`;
      }
    }
    
    // Toggle raw email content display
    function toggleEmailRawContent() {
      const rawContent = document.getElementById('emailRawContent');
      if (rawContent) {
        rawContent.style.display = rawContent.style.display === 'none' ? 'block' : 'none';
      }
    }
    
    // Close email modal
    function closeEmailModal(event) {
      if (event && event.target !== event.currentTarget) {
        return;
      }
      document.getElementById('emailModal').classList.remove('visible');
    }

    // ==================== Rule History Functions ====================
    // Requirements: 1.1, 1.2, 1.3, 5.1
    
    // Store all rules for filtering
    let allRules = [];
    let currentRuleTagFilter = '';
    let ruleHistoryCollapsed = false;
    
    // Toggle rule history panel collapse
    function toggleRuleHistoryPanel() {
      ruleHistoryCollapsed = !ruleHistoryCollapsed;
      const content = document.getElementById('ruleHistoryContent');
      const icon = document.getElementById('ruleHistoryToggleIcon');
      
      if (ruleHistoryCollapsed) {
        content.style.display = 'none';
        icon.textContent = 'â–¶';
      } else {
        content.style.display = 'block';
        icon.textContent = 'â–¼';
      }
    }
    
    // Load and display rule history
    // Requirements: 1.1 - Display list of saved extraction rules with pattern name, subject pattern, and tags
    async function loadRuleHistory() {
      const ruleList = document.getElementById('ruleHistoryList');
      const statusEl = document.getElementById('ruleHistoryStatus');
      const tagFilter = document.getElementById('ruleTagFilter');
      const tagSelect = document.getElementById('ruleTagSelect');
      const countEl = document.getElementById('ruleHistoryCount');
      
      if (!authToken) {
        ruleList.innerHTML = '<p style="color:#666;">è¯·å…ˆç™»å½•</p>';
        return;
      }
      
      try {
        const res = await apiGet('/api/patterns');

        if (!res.ok) {
          const error = await res.json();
          throw new Error(error.error || 'Failed to load rules');
        }

        const data = await res.json();
        allRules = data.patterns || [];
        
        // Update count display
        countEl.textContent = `(${allRules.length} æ¡è§„åˆ™)`;
        
        // Collect all unique tags
        const allTags = new Set();
        allRules.forEach(r => {
          if (r.tags && Array.isArray(r.tags)) {
            r.tags.forEach(t => allTags.add(t));
          }
        });
        
        // Update tag filter dropdown
        if (allTags.size > 0) {
          tagFilter.style.display = 'block';
          const currentValue = tagSelect.value;
          tagSelect.innerHTML = '<option value="">å…¨éƒ¨</option>' + 
            Array.from(allTags).sort().map(tag => 
              `<option value="${escapeHtml(tag)}" ${tag === currentRuleTagFilter ? 'selected' : ''}>${escapeHtml(tag)}</option>`
            ).join('');
        } else {
          tagFilter.style.display = 'none';
        }
        
        // Filter rules by tag
        const filteredRules = currentRuleTagFilter 
          ? allRules.filter(r => r.tags && r.tags.includes(currentRuleTagFilter))
          : allRules;

        if (filteredRules.length === 0) {
          ruleList.innerHTML = `
            <div class="rule-empty">
              <p style="font-size:16px; margin-bottom:8px;">ğŸ“ ${currentRuleTagFilter ? 'æ²¡æœ‰åŒ¹é…çš„è§„åˆ™' : 'è¿˜æ²¡æœ‰ä¿å­˜çš„è§„åˆ™'}</p>
              <p style="font-size:13px;">${currentRuleTagFilter ? 'å°è¯•é€‰æ‹©å…¶ä»–æ ‡ç­¾' : 'ä¿å­˜å¸¸ç”¨çš„æå–è§„åˆ™ä»¥ä¾¿å¿«é€Ÿåº”ç”¨'}</p>
            </div>
          `;
        } else {
          // Requirements: 1.1, 1.2 - Display pattern name, subject pattern, tags with Use and Delete buttons
          ruleList.innerHTML = filteredRules.map(rule => {
            const tagsHtml = rule.tags && rule.tags.length > 0 
              ? `<div class="rule-tags">${rule.tags.map(t => `<span class="rule-tag" onclick="event.stopPropagation(); filterRuleByTag('${escapeHtml(t)}')">${escapeHtml(t)}</span>`).join('')}</div>`
              : '';
            const ruleName = rule.patternName || 'æœªå‘½åè§„åˆ™';
            return `
            <div class="rule-item" data-id="${escapeHtml(rule.id)}">
              <div class="rule-info" onclick="useRuleFromHistory('${escapeHtml(rule.id)}')">
                <div class="rule-name">ğŸ“‹ ${escapeHtml(ruleName)}</div>
                <div class="rule-subject">ä¸»é¢˜: ${escapeHtml(rule.subjectPattern || '(æ— ä¸»é¢˜ç­›é€‰)')}</div>
                <code class="rule-regex">${escapeHtml(rule.regexPattern)}</code>
                ${tagsHtml}
                <div class="rule-meta">
                  æ ‡å¿—: ${escapeHtml(rule.regexFlags || 'g')} | 
                  åˆ›å»ºäº ${new Date(rule.createdAt).toLocaleDateString()}
                  ${rule.lastUsed ? ' | æœ€åä½¿ç”¨ ' + new Date(rule.lastUsed).toLocaleDateString() : ''}
                </div>
              </div>
              <div class="rule-actions">
                <button class="btn-use-rule" onclick="event.stopPropagation(); useRuleFromHistory('${escapeHtml(rule.id)}')">ä½¿ç”¨</button>
                <button class="btn-edit-rule" onclick="event.stopPropagation(); editRuleFromHistory('${escapeHtml(rule.id)}')">ç¼–è¾‘</button>
                <button class="btn-delete-rule" onclick="event.stopPropagation(); deleteRuleFromHistory('${escapeHtml(rule.id)}', '${escapeHtml(ruleName).replace(/'/g, "\\'")}')">åˆ é™¤</button>
              </div>
            </div>
          `}).join('');
        }
        
        if (statusEl.textContent) {
          statusEl.textContent = '';
        }
      } catch (e) {
        ruleList.innerHTML = `<p style="color:#dc3545;">âŒ åŠ è½½å¤±è´¥: ${e.message}</p>`;
      }
    }
    
    // Filter rules by tag (from dropdown)
    function filterRulesByTag() {
      currentRuleTagFilter = document.getElementById('ruleTagSelect').value;
      loadRuleHistory();
    }
    
    // Filter by clicking a tag
    function filterRuleByTag(tag) {
      currentRuleTagFilter = tag;
      document.getElementById('ruleTagSelect').value = tag;
      loadRuleHistory();
    }
    
    // Use rule from history - populate form with rule parameters
    // Requirements: 1.2, 5.1 - Click on saved rule to display full details and populate extraction form
    async function useRuleFromHistory(ruleId) {
      const statusEl = document.getElementById('ruleHistoryStatus');
      
      try {
        // Find the rule in cached data
        const rule = allRules.find(r => r.id === ruleId);
        
        if (!rule) {
          showStatus('ruleHistoryStatus', 'âŒ è§„åˆ™ä¸å­˜åœ¨', 'error');
          return;
        }

        // Populate the rule editor form with rule parameters
        document.getElementById('pattern').value = rule.regexPattern;
        document.getElementById('patternFlags').value = rule.regexFlags || 'g';
        document.getElementById('patternName').value = rule.patternName || 'default';
        document.getElementById('patternTags').value = (rule.tags || []).join(', ');
        
        // Populate subject pattern in both the rule editor and filter fields
        if (rule.subjectPattern) {
          const ruleSubjectPattern = document.getElementById('ruleSubjectPattern');
          if (ruleSubjectPattern) {
            ruleSubjectPattern.value = rule.subjectPattern;
          }
          document.getElementById('subject').value = rule.subjectPattern;
        }

        // Update current rule display in extraction options
        updateCurrentRuleDisplay(
          rule.patternName,
          rule.subjectPattern,
          rule.regexPattern,
          rule.regexFlags || 'g',
          (rule.tags || []).join(', ')
        );

        showStatus('ruleHistoryStatus', 'âœ… å·²åº”ç”¨è§„åˆ™åˆ°è¡¨å•', 'success');
        showRuleEditorStatus('âœ… å·²åŠ è½½è§„åˆ™: ' + (rule.patternName || 'æœªå‘½å'), 'success');
        
        // Update last used timestamp via API
        try {
          await apiPut(`/api/patterns/${ruleId}/use`, {});
          // Refresh the list to show updated lastUsed
          await loadRuleHistory();
        } catch (e) {
          console.log('Failed to update last used:', e);
        }
        
        // Scroll to extraction options card
        document.getElementById('extractionOptionsCard').scrollIntoView({ behavior: 'smooth', block: 'center' });
        
        // Clear success message after 3 seconds
        setTimeout(() => {
          const statusEl = document.getElementById('ruleHistoryStatus');
          if (statusEl.textContent.includes('åº”ç”¨')) {
            statusEl.textContent = '';
            statusEl.className = '';
          }
        }, 3000);
      } catch (e) {
        showStatus('ruleHistoryStatus', 'âŒ åº”ç”¨å¤±è´¥: ' + e.message, 'error');
      }
    }
    
    // Delete rule from history with confirmation
    // Requirements: 1.3 - Delete saved rule from storage and update display
    async function deleteRuleFromHistory(ruleId, ruleName) {
      if (!confirm(`ç¡®å®šè¦åˆ é™¤è§„åˆ™ "${ruleName}" å—ï¼Ÿ\n\næ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`)) {
        return;
      }

      showStatus('ruleHistoryStatus', 'æ­£åœ¨åˆ é™¤...', 'info');

      try {
        const res = await apiDelete(`/api/patterns/${ruleId}`);

        if (!res.ok) {
          const error = await res.json();
          throw new Error(error.error || 'Failed to delete rule');
        }

        showStatus('ruleHistoryStatus', 'âœ… è§„åˆ™å·²åˆ é™¤', 'success');
        
        // Reload rule history to update display
        await loadRuleHistory();
        
        // Clear success message after 3 seconds
        setTimeout(() => {
          const statusEl = document.getElementById('ruleHistoryStatus');
          if (statusEl.textContent.includes('åˆ é™¤')) {
            statusEl.textContent = '';
            statusEl.className = '';
          }
        }, 3000);
      } catch (e) {
        showStatus('ruleHistoryStatus', 'âŒ åˆ é™¤å¤±è´¥: ' + e.message, 'error');
      }
    }

    // Track which rule is being edited
    let editingPatternId = null;

    /**
     * Edit a rule from history - load into editor for modification
     */
    async function editRuleFromHistory(ruleId) {
      const rule = allRules.find(r => r.id === ruleId);
      if (!rule) {
        showStatus('ruleHistoryStatus', 'âŒ æ‰¾ä¸åˆ°è§„åˆ™', 'error');
        return;
      }

      // Set editing mode
      editingPatternId = ruleId;

      // Populate rule editor fields
      document.getElementById('patternName').value = rule.patternName || '';
      document.getElementById('ruleSubjectPattern').value = rule.subjectPattern || '';
      document.getElementById('pattern').value = rule.regexPattern || '';
      document.getElementById('patternFlags').value = rule.regexFlags || 'g';
      document.getElementById('patternTags').value = (rule.tags || []).join(', ');

      // Update save button text to indicate editing mode
      updateSaveButtonState();

      // Switch to extraction module and scroll to rule editor
      switchModule('extraction');
      setTimeout(() => {
        document.getElementById('ruleEditorCard').scrollIntoView({ behavior: 'smooth', block: 'start' });
      }, 100);

      showRuleEditorStatus('ğŸ“ æ­£åœ¨ç¼–è¾‘è§„åˆ™: ' + (rule.patternName || 'æœªå‘½å'), 'info');
      showStatus('ruleHistoryStatus', 'ğŸ“ å·²åŠ è½½è§„åˆ™åˆ°ç¼–è¾‘å™¨', 'info');
    }

    /**
     * Update save button to show editing state
     */
    function updateSaveButtonState() {
      const saveBtn = document.querySelector('#ruleEditorCard button[onclick="saveRuleToHistory()"]');
      if (saveBtn) {
        if (editingPatternId) {
          saveBtn.innerHTML = 'ğŸ’¾ æ›´æ–°è§„åˆ™';
          saveBtn.style.background = '#17a2b8';
        } else {
          saveBtn.innerHTML = 'ğŸ’¾ ä¿å­˜è§„åˆ™';
          saveBtn.style.background = '#6001d2';
        }
      }
    }

    // ==================== Legacy Pattern History Functions (for backward compatibility) ====================
    
    // Store all patterns for filtering
    let allPatterns = [];
    let currentTagFilter = '';
    
    // Load and display pattern history (legacy - calls new function)
    async function loadPatternHistory() {
      await loadRuleHistory();
    }
    
    // Filter patterns by tag (from dropdown) - legacy
    function filterPatternsByTag() {
      filterRulesByTag();
    }
    
    // Filter by clicking a tag - legacy
    function filterByTag(tag) {
      filterRuleByTag(tag);
    }

    /**
     * Save rule to history from the rule editor panel
     * Requirements: 4.6, 4.7 - Validate required fields, call POST /api/patterns to save,
     * refresh rule history list
     */
    async function saveRuleToHistory() {
      const regexPattern = document.getElementById('pattern').value.trim();
      const regexFlags = document.getElementById('patternFlags').value;
      const patternName = document.getElementById('patternName').value.trim();
      const tagsInput = document.getElementById('patternTags').value;
      
      // Get subject pattern from the new rule editor field, fallback to filter field
      const ruleSubjectPattern = document.getElementById('ruleSubjectPattern');
      const subjectPattern = ruleSubjectPattern ? ruleSubjectPattern.value.trim() : document.getElementById('subject').value.trim();

      // Validate required fields - Requirements: 4.7
      const errors = [];
      
      if (!patternName || patternName === 'default') {
        errors.push('è¯·è¾“å…¥æ¨¡å¼åç§°');
      }
      
      if (!regexPattern) {
        errors.push('è¯·è¾“å…¥æ­£åˆ™è¡¨è¾¾å¼');
      }
      
      if (errors.length > 0) {
        showRuleEditorStatus('âŒ ' + errors.join(', '), 'error');
        return;
      }

      // Validate regex syntax
      try {
        new RegExp(regexPattern, regexFlags);
      } catch (e) {
        showRuleEditorStatus('âŒ æ­£åˆ™è¡¨è¾¾å¼æ— æ•ˆ: ' + e.message, 'error');
        return;
      }
      
      // Parse tags
      const tags = tagsInput ? tagsInput.split(',').map(t => t.trim()).filter(t => t.length > 0) : [];

      const isEditing = !!editingPatternId;
      showRuleEditorStatus(isEditing ? 'æ­£åœ¨æ›´æ–°...' : 'æ­£åœ¨ä¿å­˜...', 'info');

      try {
        let res;
        if (isEditing) {
          // Update existing rule
          res = await apiPut(`/api/patterns/${editingPatternId}`, {
            patternName: patternName,
            subjectPattern: subjectPattern || '',
            regexPattern: regexPattern,
            regexFlags: regexFlags,
            tags: tags
          });
        } else {
          // Create new rule
          res = await apiPost('/api/patterns', {
            patternName: patternName,
            subjectPattern: subjectPattern || '',
            regexPattern: regexPattern,
            regexFlags: regexFlags,
            tags: tags
          });
        }

        if (!res.ok) {
          const error = await res.json();
          throw new Error(error.error || (isEditing ? 'Failed to update rule' : 'Failed to save rule'));
        }

        // Clear editing mode
        editingPatternId = null;
        updateSaveButtonState();

        showRuleEditorStatus(isEditing ? 'âœ… è§„åˆ™å·²æ›´æ–°' : 'âœ… è§„åˆ™å·²ä¿å­˜åˆ°å†å²', 'success');
        
        // Also show status in rule history section
        showStatus('ruleHistoryStatus', isEditing ? 'âœ… è§„åˆ™å·²æ›´æ–°' : 'âœ… è§„åˆ™å·²ä¿å­˜', 'success');
        
        // Reload rule history to show the new/updated rule
        await loadRuleHistory();
        
        // Clear success message after 3 seconds
        setTimeout(() => {
          const statusEl = document.getElementById('ruleHistoryStatus');
          if (statusEl.textContent.includes('ä¿å­˜') || statusEl.textContent.includes('æ›´æ–°')) {
            statusEl.textContent = '';
            statusEl.className = '';
          }
        }, 3000);
        
      } catch (e) {
        showRuleEditorStatus('âŒ ' + (isEditing ? 'æ›´æ–°' : 'ä¿å­˜') + 'å¤±è´¥: ' + e.message, 'error');
      }
    }

    // Save current pattern to server (legacy function - calls new saveRuleToHistory)
    async function savePatternToServer() {
      await saveRuleToHistory();
    }

    // Apply pattern from history to form (legacy - redirects to useRuleFromHistory)
    async function applyPatternFromHistory(patternId) {
      await useRuleFromHistory(patternId);
    }

    // Delete pattern from history (legacy - redirects to deleteRuleFromHistory)
    async function deletePatternFromHistory(patternId, patternName) {
      await deleteRuleFromHistory(patternId, patternName);
    }
    
    // Check if user is already authenticated on page load
    async function checkAuth() {
      const savedToken = sessionStorage.getItem('authToken');
      const savedUser = sessionStorage.getItem('currentUser');
      
      if (savedToken && savedUser) {
        try {
          // Temporarily set the token for the API call
          authToken = savedToken;
          
          // Verify token is still valid
          const res = await apiGet('/api/auth/me');

          if (res.ok) {
            const data = await res.json();
            currentUser = data.user;
            showMainApp();
            return;
          }
        } catch (e) {
          console.error('Auth check failed:', e);
        }
        
        // Token invalid, clear session
        authToken = null;
        sessionStorage.removeItem('authToken');
        sessionStorage.removeItem('currentUser');
      }
      
      // Show login page
      showLoginPage();
    }

    // ==================== Server Status ====================
    
    async function checkServerStatus() {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 15000);
        
        const res = await fetch(`${API}/api/connect`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ email: 'test', password: 'test' }),
          signal: controller.signal
        });
        clearTimeout(timeoutId);
        
        document.getElementById('serverStatus').innerHTML = 'âœ… æœåŠ¡å™¨è¿è¡Œä¸­';
        document.getElementById('serverStatus').style.color = '#2e7d32';
      } catch (e) {
        if (e.name === 'AbortError') {
          document.getElementById('serverStatus').innerHTML = 'â³ æœåŠ¡å™¨å“åº”ç¼“æ…¢ï¼Œè¯·ç¨å€™...';
          document.getElementById('serverStatus').style.color = '#ff9800';
        } else {
          document.getElementById('serverStatus').innerHTML = 'âŒ æœåŠ¡å™¨æœªå“åº”<br><small>è¯·è¿è¡Œ: npm run web</small>';
          document.getElementById('serverStatus').style.color = '#dc3545';
        }
        console.error('Server check failed:', e.message);
      }
    }

    // ==================== Page Initialization ====================
    
    document.addEventListener('DOMContentLoaded', async () => {
      const delayInput = document.getElementById('delayMs');
      if (delayInput) {
        delayInput.addEventListener('input', (e) => {
          document.getElementById('delayValue').textContent = e.target.value + 'ms';
        });
      }

      // Check authentication status
      await checkAuth();
    });

    // ==================== Email Connection Functions ====================

    async function connect() {
      const email = document.getElementById('email').value;
      const password = document.getElementById('password').value;
      
      if (!email || !password) {
        showStatus('connectionStatus', 'è¯·è¾“å…¥é‚®ç®±å’Œå¯†ç ', 'error');
        return;
      }

      showStatus('connectionStatus', 'æ­£åœ¨è¿æ¥...', 'info');
      
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000);
        
        // Use apiPost for connect - includes auth token
        const res = await apiRequest('/api/connect', {
          method: 'POST',
          body: JSON.stringify({ email, password }),
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!res.ok) {
          const error = await res.json();
          showStatus('connectionStatus', `è¿æ¥å¤±è´¥: ${error.error || 'Unknown error'}`, 'error');
          return;
        }
        
        const data = await res.json();
        
        if (data.success) {
          sessionId = data.sessionId;
          document.getElementById('connectionForm').classList.add('hidden');
          document.getElementById('connectedInfo').classList.remove('hidden');
          document.getElementById('connectedEmail').textContent = email;
          
          // Filter out virtual parent folders (like [Gmail])
          const virtualFolders = ['[Gmail]', '[Google Mail]'];
          const validFolders = data.folders.filter(f => !virtualFolders.includes(f));
          
          const folderSelect = document.getElementById('folder');
          folderSelect.innerHTML = validFolders.map(f => `<option value="${f}">${f}</option>`).join('');
          
          showStatus('connectionStatus', 'âœ… è¿æ¥æˆåŠŸï¼', 'success');
          
          // Initialize email management if currently on that module
          if (currentModule === 'email-management') {
            initEmailManagement();
          }
        } else {
          showStatus('connectionStatus', `è¿æ¥å¤±è´¥: ${data.error || 'Unknown error'}`, 'error');
        }
      } catch (e) {
        if (e.name === 'AbortError') {
          showStatus('connectionStatus', 'âŒ è¿æ¥è¶…æ—¶ (30 ç§’)ã€‚è¯·æ£€æŸ¥ï¼š\n1. æœåŠ¡å™¨æ˜¯å¦è¿è¡Œ (npm run web)\n2. ç½‘ç»œè¿æ¥\n3. Yahoo é‚®ç®±å’Œå¯†ç æ˜¯å¦æ­£ç¡®', 'error');
        } else {
          showStatus('connectionStatus', `âŒ è¿æ¥é”™è¯¯: ${e.message}\n\nè¯·æ£€æŸ¥ï¼š\n1. æœåŠ¡å™¨æ˜¯å¦è¿è¡Œ (npm run web)\n2. æµè§ˆå™¨æ§åˆ¶å° (F12) æŸ¥çœ‹è¯¦ç»†é”™è¯¯`, 'error');
        }
        console.error('Connection error:', e);
      }
    }

    async function disconnect() {
      if (!confirm('ç¡®å®šè¦æ–­å¼€è¿æ¥å—ï¼Ÿ')) {
        return;
      }

      try {
        if (sessionId) {
          const res = await apiPost('/api/disconnect', { sessionId });
          
          if (!res.ok) {
            console.error('Disconnect failed:', res.status);
          }
        }
        
        sessionId = null;
        document.getElementById('connectionForm').classList.remove('hidden');
        document.getElementById('connectedInfo').classList.add('hidden');
        document.getElementById('resultsCard').classList.add('hidden');
        document.getElementById('connectionStatus').innerHTML = '';
        
        document.getElementById('email').value = '';
        document.getElementById('password').value = '';
        
        // Reset email management state
        emailMgmtState = {
          currentFolder: null,
          folders: [],
          emails: [],
          conversations: [],
          selectedUids: new Set(),
          pagination: { page: 1, pageSize: 20, totalCount: 0, totalPages: 0 },
          searchPattern: '',
          isSearchMode: false,
          sortOrder: 'desc',
          viewMode: 'list'
        };
        
        // Re-initialize email management if on that module
        if (currentModule === 'email-management') {
          initEmailManagement();
        }
        
        showStatus('connectionStatus', 'âœ… å·²æ–­å¼€è¿æ¥', 'success');
        setTimeout(() => {
          document.getElementById('connectionStatus').innerHTML = '';
        }, 3000);
      } catch (e) {
        console.error('Disconnect error:', e);
        showStatus('connectionStatus', 'âŒ æ–­å¼€è¿æ¥å¤±è´¥: ' + e.message, 'error');
      }
    }

    function getFilter() {
      return {
        folder: document.getElementById('folder').value,
        dateFrom: document.getElementById('dateFrom').value || undefined,
        dateTo: document.getElementById('dateTo').value || undefined,
        sender: document.getElementById('sender').value || undefined,
        subject: document.getElementById('subject').value || undefined
      };
    }

    async function countEmails() {
      const countResult = document.getElementById('countResult');
      countResult.classList.remove('hidden');
      countResult.textContent = 'æ­£åœ¨ç»Ÿè®¡... (æœ€å¤šç­‰å¾… 30 ç§’)';
      countResult.className = 'status info';
      
      // Reset rule editor for new extraction task
      clearRuleEditor();
      
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 35000);
        
        const res = await apiRequest('/api/count', {
          method: 'POST',
          body: JSON.stringify({ sessionId, filter: getFilter() }),
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!res.ok) {
          const error = await res.json();
          throw new Error(error.error || 'Count failed');
        }
        
        const data = await res.json();
        countResult.textContent = `âœ… æ‰¾åˆ° ${data.count} å°ç¬¦åˆæ¡ä»¶çš„é‚®ä»¶`;
        countResult.className = 'status success';
      } catch (e) {
        if (e.name === 'AbortError') {
          countResult.textContent = 'âŒ ç»Ÿè®¡è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–é‚®ä»¶æ•°é‡è¿‡å¤š';
        } else {
          countResult.textContent = 'âŒ ç»Ÿè®¡å¤±è´¥: ' + e.message;
        }
        countResult.className = 'status error';
      }
    }

    async function previewEmail() {
      const previewContainer = document.getElementById('previewContainer');
      const previewResult = document.getElementById('previewResult');
      previewContainer.classList.remove('hidden');
      previewResult.innerHTML = 'æ­£åœ¨è·å–é¢„è§ˆ...';
      
      // Reset search state
      clearPreviewSearch();
      
      // Reset rule editor for new extraction task
      clearRuleEditor();
      
      try {
        const res = await apiPost('/api/preview', { sessionId, filter: getFilter() });
        
        const data = await res.json();
        if (data.error) {
          previewResult.innerHTML = escapeHtml('é”™è¯¯: ' + data.error);
        } else if (data.content) {
          // Store original content for search functionality
          previewEmailContent = data.content;
          previewEmailMetadata = {
            subject: data.subject,
            from: data.from,
            date: data.date,
            contentLength: data.contentLength
          };
          
          const preview = `=== ä¸»é¢˜: ${data.subject} ===\n=== å‘ä»¶äºº: ${data.from} ===\n=== æ—¥æœŸ: ${data.date} ===\n=== å†…å®¹é•¿åº¦: ${data.contentLength} å­—ç¬¦ ===\n\n${data.content}`;
          previewResult.innerHTML = escapeHtml(preview);
          
          // Enable text selection for rule generation
          setupTextSelectionHandler();
        } else {
          previewResult.innerHTML = 'æ²¡æœ‰æ‰¾åˆ°é‚®ä»¶';
        }
      } catch (e) {
        previewResult.innerHTML = escapeHtml('é¢„è§ˆå¤±è´¥: ' + e.message);
      }
    }

    // ==================== Email Preview Search Functions ====================
    // Requirements: 2.3, 2.4, 2.5
    
    // Store preview content and search state
    let previewEmailContent = '';
    let previewEmailMetadata = null;
    let previewSearchMatches = [];
    let previewCurrentMatchIndex = -1;
    let previewOriginalContent = '';
    
    /**
     * Handle keydown events in search input
     * Requirements: 2.4
     */
    function handlePreviewSearchKeydown(event) {
      if (event.key === 'Enter') {
        if (event.shiftKey) {
          navigatePreviewSearch('prev');
        } else {
          if (previewSearchMatches.length > 0) {
            navigatePreviewSearch('next');
          } else {
            searchInPreview();
          }
        }
        event.preventDefault();
      } else if (event.key === 'Escape') {
        clearPreviewSearch();
      }
    }
    
    /**
     * Search for text in the email preview
     * Requirements: 2.4 - WHEN the user searches in the preview THEN the System SHALL 
     * highlight all matching occurrences and navigate between them
     */
    function searchInPreview() {
      const searchInput = document.getElementById('previewSearchInput');
      const previewResult = document.getElementById('previewResult');
      const searchCount = document.getElementById('previewSearchCount');
      const prevBtn = document.getElementById('previewSearchPrev');
      const nextBtn = document.getElementById('previewSearchNext');
      
      const query = searchInput.value.trim();
      
      if (!query) {
        clearPreviewSearch();
        return;
      }
      
      // Get the full preview text (including metadata)
      const fullPreview = previewResult.textContent || previewResult.innerText;
      if (!fullPreview) {
        searchCount.textContent = '0/0';
        return;
      }
      
      // Store original content for restoration
      if (!previewOriginalContent) {
        previewOriginalContent = fullPreview;
      }
      
      // Find all matches (case-insensitive)
      previewSearchMatches = [];
      const lowerContent = fullPreview.toLowerCase();
      const lowerQuery = query.toLowerCase();
      let startIndex = 0;
      let foundIndex;
      
      while ((foundIndex = lowerContent.indexOf(lowerQuery, startIndex)) !== -1) {
        previewSearchMatches.push({
          index: foundIndex,
          length: query.length,
          text: fullPreview.substring(foundIndex, foundIndex + query.length)
        });
        startIndex = foundIndex + 1;
      }
      
      // Update UI
      if (previewSearchMatches.length === 0) {
        searchCount.textContent = '0/0';
        prevBtn.disabled = true;
        nextBtn.disabled = true;
        previewResult.innerHTML = escapeHtml(fullPreview);
        return;
      }
      
      // Enable navigation buttons
      prevBtn.disabled = false;
      nextBtn.disabled = false;
      
      // Set current match to first one
      previewCurrentMatchIndex = 0;
      
      // Highlight all matches and show current
      highlightPreviewMatches(fullPreview, query);
      
      // Update count display
      updatePreviewSearchCount();
      
      // Scroll to first match
      scrollToCurrentMatch();
    }
    
    /**
     * Highlight all matches in the preview content
     * Requirements: 2.4
     */
    function highlightPreviewMatches(content, query) {
      const previewResult = document.getElementById('previewResult');
      
      if (previewSearchMatches.length === 0) {
        previewResult.innerHTML = escapeHtml(content);
        return;
      }
      
      // Build HTML with highlighted matches
      const htmlParts = [];
      let lastIndex = 0;
      
      for (let i = 0; i < previewSearchMatches.length; i++) {
        const match = previewSearchMatches[i];
        
        // Add text before this match (escaped)
        if (match.index > lastIndex) {
          htmlParts.push(escapeHtml(content.substring(lastIndex, match.index)));
        }
        
        // Add highlighted match with navigation data attribute
        const matchText = content.substring(match.index, match.index + match.length);
        const isCurrent = i === previewCurrentMatchIndex;
        htmlParts.push(
          `<span class="search-highlight${isCurrent ? ' current' : ''}" data-match-index="${i}">${escapeHtml(matchText)}</span>`
        );
        
        lastIndex = match.index + match.length;
      }
      
      // Add remaining text after last match
      if (lastIndex < content.length) {
        htmlParts.push(escapeHtml(content.substring(lastIndex)));
      }
      
      previewResult.innerHTML = htmlParts.join('');
    }
    
    /**
     * Navigate between search matches
     * Requirements: 2.4 - Navigate between matches with up/down buttons
     */
    function navigatePreviewSearch(direction) {
      if (previewSearchMatches.length === 0) {
        return;
      }
      
      // Update current match index
      if (direction === 'next') {
        previewCurrentMatchIndex = (previewCurrentMatchIndex + 1) % previewSearchMatches.length;
      } else {
        previewCurrentMatchIndex = previewCurrentMatchIndex <= 0 
          ? previewSearchMatches.length - 1 
          : previewCurrentMatchIndex - 1;
      }
      
      // Update highlight classes
      updateCurrentMatchHighlight();
      
      // Update count display
      updatePreviewSearchCount();
      
      // Scroll to current match
      scrollToCurrentMatch();
    }
    
    /**
     * Update the current match highlight
     */
    function updateCurrentMatchHighlight() {
      const previewResult = document.getElementById('previewResult');
      
      // Remove current class from all highlights
      const allHighlights = previewResult.querySelectorAll('.search-highlight');
      allHighlights.forEach(el => el.classList.remove('current'));
      
      // Add current class to current match
      const currentHighlight = previewResult.querySelector(`[data-match-index="${previewCurrentMatchIndex}"]`);
      if (currentHighlight) {
        currentHighlight.classList.add('current');
      }
    }
    
    /**
     * Scroll to the current match in the preview
     */
    function scrollToCurrentMatch() {
      const previewResult = document.getElementById('previewResult');
      const currentHighlight = previewResult.querySelector('.search-highlight.current');
      
      if (currentHighlight) {
        currentHighlight.scrollIntoView({
          behavior: 'smooth',
          block: 'center'
        });
      }
    }
    
    /**
     * Update the search count display
     */
    function updatePreviewSearchCount() {
      const searchCount = document.getElementById('previewSearchCount');
      if (previewSearchMatches.length === 0) {
        searchCount.textContent = '0/0';
      } else {
        searchCount.textContent = `${previewCurrentMatchIndex + 1}/${previewSearchMatches.length}`;
      }
    }
    
    /**
     * Clear the preview search
     */
    function clearPreviewSearch() {
      const searchInput = document.getElementById('previewSearchInput');
      const previewResult = document.getElementById('previewResult');
      const searchCount = document.getElementById('previewSearchCount');
      const prevBtn = document.getElementById('previewSearchPrev');
      const nextBtn = document.getElementById('previewSearchNext');
      
      // Clear search input
      searchInput.value = '';
      
      // Reset search state
      previewSearchMatches = [];
      previewCurrentMatchIndex = -1;
      
      // Restore original content if available
      if (previewOriginalContent) {
        previewResult.innerHTML = escapeHtml(previewOriginalContent);
      }
      previewOriginalContent = '';
      
      // Update UI
      searchCount.textContent = '0/0';
      prevBtn.disabled = true;
      nextBtn.disabled = true;
    }
    
    /**
     * Setup text selection handler for rule generation
     * Requirements: 2.5 - WHEN the user selects text in the preview THEN the System 
     * SHALL enable the "Generate Rule" action with the selected text
     */
    function setupTextSelectionHandler() {
      const previewResult = document.getElementById('previewResult');
      const generateBtn = document.getElementById('generateRuleBtn');
      
      // Handle selection change
      previewResult.addEventListener('mouseup', function() {
        const selection = window.getSelection();
        const selectedText = selection.toString().trim();
        
        if (selectedText && selectedText.length > 0) {
          generateBtn.disabled = false;
          generateBtn.title = `ç”Ÿæˆè§„åˆ™: "${selectedText.substring(0, 30)}${selectedText.length > 30 ? '...' : ''}"`;
        } else {
          generateBtn.disabled = true;
          generateBtn.title = 'é€‰æ‹©æ–‡æœ¬åå¯ç”Ÿæˆè§„åˆ™';
        }
      });
      
      // Also handle keyboard selection
      previewResult.addEventListener('keyup', function() {
        const selection = window.getSelection();
        const selectedText = selection.toString().trim();
        
        if (selectedText && selectedText.length > 0) {
          generateBtn.disabled = false;
        } else {
          generateBtn.disabled = true;
        }
      });
    }
    
    /**
     * Generate rule from selected text in preview
     * Requirements: 2.5 - Enable the "Generate Rule" action with the selected text
     */
    function generateRuleFromSelection() {
      const selection = window.getSelection();
      const selectedText = selection.toString().trim();
      
      if (!selectedText || selectedText.length === 0) {
        alert('è¯·å…ˆåœ¨é‚®ä»¶é¢„è§ˆä¸­é€‰æ‹©è¦æå–çš„ç›®æ ‡æ–‡æœ¬');
        return;
      }
      
      // Fill the target string input with selected text
      document.getElementById('targetString').value = selectedText;
      
      // Scroll to the rule editor card
      document.getElementById('ruleEditorCard').scrollIntoView({ behavior: 'smooth', block: 'start' });
      
      // Trigger the generate function
      setTimeout(() => {
        generateRuleFromTarget();
      }, 500);
    }

    // ==================== Extraction Functions ====================

    async function extract() {
      const pattern = document.getElementById('pattern').value;
      if (!pattern) {
        alert('è¯·è¾“å…¥æ­£åˆ™è¡¨è¾¾å¼');
        return;
      }

      try {
        new RegExp(pattern, document.getElementById('patternFlags').value);
      } catch (e) {
        alert('æ­£åˆ™è¡¨è¾¾å¼æ— æ•ˆ: ' + e.message);
        return;
      }

      document.getElementById('resultsCard').classList.remove('hidden');
      showStatus('extractStatus', 'æ­£åœ¨æå–... è¯·ç¨å€™ï¼ˆå•çº¿ç¨‹å¤„ç†ï¼‰', 'info');
      
      // Hide resume buttons when starting new extraction
      hideResumeButtons();
      
      document.getElementById('matchesList').innerHTML = '';
      document.getElementById('results').innerHTML = '';
      document.getElementById('progressBar').style.width = '0%';
      document.getElementById('progressPercent').textContent = '0%';
      document.getElementById('progressText').textContent = 'å‡†å¤‡ä¸­...';
      extractedResults = [];
      
      const skipCount = parseInt(document.getElementById('skipCount').value) || 0;
      
      try {
        const delayMs = parseInt(document.getElementById('delayMs').value) || 100;
        // Use apiRequest for streaming endpoint
        const res = await apiRequest('/api/extract', {
          method: 'POST',
          body: JSON.stringify({
            sessionId,
            filter: getFilter(),
            pattern: {
              name: document.getElementById('patternName').value,
              pattern: pattern,
              flags: document.getElementById('patternFlags').value
            },
            stripHtml: document.getElementById('stripHtml').checked,
            delayMs: delayMs,
            skipCount: skipCount
          })
        });
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: 'Unknown error' }));
          throw new Error(errorData.error || `HTTP ${res.status}`);
        }
        
        if (!res.body) {
          throw new Error('Response body is empty');
        }
        
        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        let totalEmails = 0;
        let originalTotal = 0;
        let skippedCount = 0;
        let totalMatches = 0;
        let matchesList = [];
        let lastProcessed = 0;

        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            
            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split('\n');
            buffer = lines.pop() || '';

            for (const line of lines) {
              if (!line) continue;
              
              try {
                const data = JSON.parse(line);
                
                if (data.type === 'init') {
                  totalEmails = data.total;
                  originalTotal = data.originalTotal || data.total;
                  skippedCount = data.skipped || 0;
                  if (skippedCount > 0) {
                    document.getElementById('progressText').textContent = `0 / ${totalEmails} (è·³è¿‡ ${skippedCount})`;
                    showStatus('extractStatus', `æ­£åœ¨æå–... è·³è¿‡å‰ ${skippedCount} å°ï¼Œå¤„ç†å‰©ä½™ ${totalEmails} å°`, 'info');
                  } else {
                    document.getElementById('progressText').textContent = `0 / ${totalEmails}`;
                  }
                } else if (data.type === 'progress') {
                  lastProcessed = data.processed;
                  const percent = Math.round((data.processed / totalEmails) * 100);
                  document.getElementById('progressBar').style.width = percent + '%';
                  document.getElementById('progressPercent').textContent = percent + '%';
                  if (skippedCount > 0) {
                    document.getElementById('progressText').textContent = `${data.processed} / ${totalEmails} (è·³è¿‡ ${skippedCount})`;
                  } else {
                    document.getElementById('progressText').textContent = `${data.processed} / ${totalEmails}`;
                  }
                  
                  if (data.matches && data.matches.length > 0) {
                    // Deduplicate matches (case-insensitive)
                    const seenInBatch = new Set();
                    const uniqueMatches = data.matches.filter(match => {
                      const key = match.fullMatch.toLowerCase();
                      if (seenInBatch.has(key)) {
                        return false;
                      }
                      seenInBatch.add(key);
                      return true;
                    });
                    
                    uniqueMatches.forEach(match => {
                      totalMatches++;
                      matchesList.push(match);
                    });
                    
                    // Performance optimization: batch DOM updates and limit displayed items
                    const matchesListEl = document.getElementById('matchesList');
                    const matchesDiv = document.getElementById('liveMatches');
                    const maxDisplayed = 200; // Only show last 200 matches in real-time view
                    
                    // Only update DOM every 10 matches or when we have new matches
                    if (totalMatches % 10 === 0 || uniqueMatches.length > 0) {
                      // Get last N matches to display
                      const displayMatches = matchesList.slice(-maxDisplayed);
                      
                      // Use DocumentFragment for better performance
                      const fragment = document.createDocumentFragment();
                      
                      // Clear and rebuild (more efficient than innerHTML += for large lists)
                      matchesListEl.innerHTML = '';
                      
                      // Add truncation notice if needed
                      if (matchesList.length > maxDisplayed) {
                        const notice = document.createElement('div');
                        notice.style.cssText = 'padding:8px; margin:5px 0; background:#fff3e0; border-radius:3px; text-align:center; color:#e65100; font-size:12px;';
                        notice.textContent = `æ˜¾ç¤ºæœ€è¿‘ ${maxDisplayed} æ¡ï¼ˆå…± ${matchesList.length} æ¡åŒ¹é…ï¼‰`;
                        fragment.appendChild(notice);
                      }
                      
                      displayMatches.forEach(match => {
                        const div = document.createElement('div');
                        div.style.cssText = 'padding:8px; margin:5px 0; background:white; border-radius:3px; border-left:3px solid #6001d2;';
                        div.innerHTML = `<strong style="color:#6001d2;">${escapeHtml(match.fullMatch)}</strong><br><small style="color:#666;">ğŸ“§ ${escapeHtml(match.subject?.substring(0, 30) || '')}... | ğŸ‘¤ ${escapeHtml(match.from?.substring(0, 20) || '')}</small>`;
                        fragment.appendChild(div);
                      });
                      
                      matchesListEl.appendChild(fragment);
                      matchesDiv.scrollTop = matchesDiv.scrollHeight;
                    }
                  }
                } else if (data.type === 'complete') {
                  extractedResults = data.results;
                  const totalProcessed = skippedCount + data.processed;
                  showStatus('extractStatus', 
                    `âœ… å®Œæˆï¼å¤„ç† ${data.processed} å°é‚®ä»¶${skippedCount > 0 ? ` (è·³è¿‡ ${skippedCount})` : ''}ï¼Œæå– ${totalMatches} ä¸ªåŒ¹é…é¡¹ï¼Œ${data.errors} ä¸ªé”™è¯¯`, 
                    'success');
                  renderResults(data.results);
                  // Reset skip count after successful completion
                  document.getElementById('skipCount').value = '0';
                } else if (data.type === 'error') {
                  showStatus('extractStatus', 'âŒ é”™è¯¯: ' + data.error, 'error');
                }
              } catch (e) {
                console.error('Parse error:', e);
              }
            }
          }
        } catch (streamError) {
          // Stream reading error - connection might have been lost
          console.error('Stream error:', streamError);
          
          if (lastProcessed > 0) {
            // Calculate total processed including skipped
            const totalProcessedSoFar = skippedCount + lastProcessed;
            
            // Auto-set skip count for resume
            document.getElementById('skipCount').value = totalProcessedSoFar.toString();
            
            // Check if this might be Gmail bandwidth limit
            const isGmailLimit = totalProcessedSoFar > 2000;
            
            let errorMsg = `âš ï¸ è¿æ¥ä¸­æ–­ï¼å·²å¤„ç† ${lastProcessed}/${totalEmails} å°é‚®ä»¶${skippedCount > 0 ? ` (è·³è¿‡ ${skippedCount})` : ''}ï¼Œæå– ${totalMatches} ä¸ªåŒ¹é…é¡¹ã€‚\n\n`;
            
            if (isGmailLimit) {
              errorMsg += `ğŸ”´ å¯èƒ½è§¦å‘äº† Gmail IMAP å¸¦å®½é™åˆ¶ï¼ˆæ¯å¤© 2500MBï¼‰\n`;
              errorMsg += `Gmail ä¼šåœ¨ 1-24 å°æ—¶åè‡ªåŠ¨è§£é™¤é™åˆ¶ã€‚\n\n`;
            }
            
            errorMsg += `âœ… å·²è‡ªåŠ¨è®¾ç½®è·³è¿‡æ•°ä¸º ${totalProcessedSoFar}ï¼Œå¯ä½¿ç”¨ä¸‹æ–¹æŒ‰é’®é‡æ–°è¿æ¥å¹¶ç»§ç»­æå–ã€‚`;
            
            showStatus('extractStatus', errorMsg, 'error');
            
            // Show resume buttons
            showResumeButtons();
          } else {
            throw streamError;
          }
        }
      } catch (e) {
        console.error('Extract error:', e);
        let errorMsg = e.message || 'Unknown error';
        
        // Provide more helpful error messages
        if (errorMsg.toLowerCase().includes('network') || errorMsg.toLowerCase().includes('fetch')) {
          errorMsg = 'ç½‘ç»œè¿æ¥é”™è¯¯ã€‚å¯èƒ½åŸå› ï¼š\n' +
            '1) æœåŠ¡å™¨æœªè¿è¡Œæˆ–å·²å´©æºƒ\n' +
            '2) ç½‘ç»œè¿æ¥ä¸ç¨³å®š\n' +
            '3) è¯·æ±‚è¶…æ—¶ï¼ˆé‚®ä»¶æ•°é‡è¿‡å¤šï¼‰\n\n' +
            'å»ºè®®ï¼šæ£€æŸ¥æœåŠ¡å™¨çŠ¶æ€ï¼Œæˆ–ä½¿ç”¨æ—¥æœŸç­›é€‰å‡å°‘é‚®ä»¶æ•°é‡';
        } else if (errorMsg.includes('Not connected')) {
          errorMsg = 'é‚®ç®±è¿æ¥å·²æ–­å¼€ã€‚è¯·è¿”å›é‚®ç®±ç®¡ç†é‡æ–°è¿æ¥ã€‚';
        } else if (errorMsg.toLowerCase().includes('bandwidth')) {
          errorMsg = 'è§¦å‘äº† Gmail IMAP å¸¦å®½é™åˆ¶ã€‚\n' +
            'Gmail æ¯å¤©é™åˆ¶ IMAP ä¸‹è½½ 2500MBã€‚\n' +
            'è¯·ç­‰å¾… 1-24 å°æ—¶åå†è¯•ã€‚';
        }
        
        showStatus('extractStatus', 'âŒ æå–å¤±è´¥: ' + errorMsg, 'error');
      }
    }

    // Reconnect to mailbox for resume extraction
    async function reconnectAndResume() {
      const resumeStatus = document.getElementById('resumeStatus');
      const continueBtn = document.getElementById('continueExtractBtn');
      
      resumeStatus.textContent = 'æ­£åœ¨é‡æ–°è¿æ¥...';
      resumeStatus.style.color = '#ff9800';
      continueBtn.disabled = true;
      
      try {
        // Get current mailbox credentials
        if (!currentMailboxId) {
          throw new Error('æ²¡æœ‰é€‰ä¸­çš„é‚®ç®±ï¼Œè¯·å…ˆåœ¨é‚®ç®±ç®¡ç†ä¸­é€‰æ‹©ä¸€ä¸ªé‚®ç®±');
        }
        
        // Get password for the mailbox
        const pwdRes = await apiRequest(`/api/mailboxes/${currentMailboxId}/password`);
        const pwdData = await pwdRes.json();
        
        if (!pwdData.success) {
          throw new Error('æ— æ³•è·å–é‚®ç®±å¯†ç ');
        }
        
        // Disconnect existing session if any
        if (sessionId) {
          try {
            await apiRequest('/api/disconnect', {
              method: 'POST',
              body: JSON.stringify({ sessionId })
            });
          } catch (e) {
            // Ignore disconnect errors
          }
        }
        
        // Reconnect
        const connectRes = await apiRequest('/api/connect', {
          method: 'POST',
          body: JSON.stringify({
            email: pwdData.email,
            password: pwdData.password,
            provider: currentProvider || 'gmail'
          })
        });
        
        const connectData = await connectRes.json();
        
        if (connectData.success) {
          sessionId = connectData.sessionId;
          folders = connectData.folders || [];
          
          resumeStatus.textContent = 'âœ… è¿æ¥æˆåŠŸï¼å¯ä»¥ç»§ç»­æå–';
          resumeStatus.style.color = '#4caf50';
          continueBtn.disabled = false;
          
          // Update connection status in UI
          updateConnectionStatus(true, pwdData.email);
        } else {
          throw new Error(connectData.error || 'è¿æ¥å¤±è´¥');
        }
      } catch (e) {
        console.error('Reconnect error:', e);
        resumeStatus.textContent = 'âŒ è¿æ¥å¤±è´¥: ' + e.message;
        resumeStatus.style.color = '#f44336';
        continueBtn.disabled = true;
      }
    }

    // Continue extraction from where it left off
    async function continueExtract() {
      const skipCount = parseInt(document.getElementById('skipCount').value) || 0;
      
      if (skipCount === 0) {
        alert('è·³è¿‡æ•°ä¸º 0ï¼Œå°†ä»å¤´å¼€å§‹æå–ã€‚å¦‚éœ€ä»æ–­ç‚¹ç»§ç»­ï¼Œè¯·ç¡®ä¿è·³è¿‡æ•°å·²æ­£ç¡®è®¾ç½®ã€‚');
      }
      
      // Hide resume buttons
      document.getElementById('resumeButtons').style.display = 'none';
      
      // Call extract function
      await extract();
    }

    // Show resume buttons when extraction is interrupted
    function showResumeButtons() {
      document.getElementById('resumeButtons').style.display = 'block';
      document.getElementById('resumeStatus').textContent = '';
      document.getElementById('continueExtractBtn').disabled = true;
    }

    // Hide resume buttons
    function hideResumeButtons() {
      document.getElementById('resumeButtons').style.display = 'none';
    }

    function renderResults(results) {
      const container = document.getElementById('results');
      
      // Check if there are any results with matches
      const hasMatches = results.some(r => r.matches && r.matches.length > 0);
      
      if (!hasMatches) {
        // Requirements: 5.5 - Display clear message when no matches found
        container.innerHTML = `
          <div style="text-align:center; padding:30px; background:#f9f9f9; border-radius:6px; border:1px dashed #ddd;">
            <p style="font-size:48px; margin-bottom:10px;">ğŸ“­</p>
            <h3 style="color:#666; margin-bottom:10px;">æœªæ‰¾åˆ°åŒ¹é…çš„æŠ˜æ‰£ç </h3>
            <p style="color:#999; margin:0; font-size:14px;">æ ¹æ®å½“å‰çš„ç­›é€‰æ¡ä»¶å’Œæ­£åˆ™è¡¨è¾¾å¼ï¼Œæ²¡æœ‰æ‰¾åˆ°ä»»ä½•åŒ¹é…çš„æŠ˜æ‰£ç ã€‚</p>
            <p style="color:#999; margin:10px 0 0 0; font-size:13px;">è¯·å°è¯•è°ƒæ•´ç­›é€‰æ¡ä»¶æˆ–ä¿®æ”¹æ­£åˆ™è¡¨è¾¾å¼ã€‚</p>
          </div>
        `;
        return;
      }

      const groupNames = new Set();
      results.forEach(r => r.matches.forEach(m => Object.keys(m.groups).forEach(k => groupNames.add(k))));
      const groups = Array.from(groupNames);

      let html = '<table><thead><tr><th>æ—¥æœŸ</th><th>å‘ä»¶äºº</th><th>ä¸»é¢˜</th><th>åŒ¹é…å†…å®¹</th>';
      groups.forEach(g => html += `<th>${g}</th>`);
      html += '</tr></thead><tbody>';

      results.forEach(r => {
        if (r.matches.length === 0) return;
        
        // Deduplicate matches by fullMatch value (case-insensitive)
        const seenMatches = new Set();
        const uniqueMatches = r.matches.filter(m => {
          const key = m.fullMatch.toLowerCase();
          if (seenMatches.has(key)) {
            return false;
          }
          seenMatches.add(key);
          return true;
        });
        
        uniqueMatches.forEach((m, i) => {
          html += '<tr>';
          if (i === 0) {
            html += `<td rowspan="${uniqueMatches.length}">${new Date(r.email.date).toLocaleDateString()}</td>`;
            html += `<td rowspan="${uniqueMatches.length}">${escapeHtml(r.email.from)}</td>`;
            html += `<td rowspan="${uniqueMatches.length}">${escapeHtml(r.email.subject)}</td>`;
          }
          html += `<td><span class="match">${escapeHtml(m.fullMatch)}</span></td>`;
          groups.forEach(g => html += `<td>${escapeHtml(m.groups[g] || '')}</td>`);
          html += '</tr>';
        });
      });

      html += '</tbody></table>';
      container.innerHTML = html;
    }

    function exportCSV() {
      if (extractedResults.length === 0) {
        alert('æ²¡æœ‰å¯å¯¼å‡ºçš„æ•°æ®');
        return;
      }

      const groupNames = new Set();
      extractedResults.forEach(r => r.matches.forEach(m => Object.keys(m.groups).forEach(k => groupNames.add(k))));
      const groups = Array.from(groupNames);

      let csv = 'Date,From,Subject,Match,' + groups.join(',') + '\n';
      
      extractedResults.forEach(r => {
        // Deduplicate matches by fullMatch value (case-insensitive)
        const seenMatches = new Set();
        const uniqueMatches = r.matches.filter(m => {
          const key = m.fullMatch.toLowerCase();
          if (seenMatches.has(key)) {
            return false;
          }
          seenMatches.add(key);
          return true;
        });
        
        uniqueMatches.forEach(m => {
          csv += `"${new Date(r.email.date).toISOString()}",`;
          csv += `"${r.email.from.replace(/"/g, '""')}",`;
          csv += `"${r.email.subject.replace(/"/g, '""')}",`;
          csv += `"${m.fullMatch.replace(/"/g, '""')}",`;
          csv += groups.map(g => `"${(m.groups[g] || '').replace(/"/g, '""')}"`).join(',');
          csv += '\n';
        });
      });

      const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const now = new Date();
      const timestamp = now.toISOString().slice(0,10) + '_' + 
        now.getHours().toString().padStart(2,'0') + 
        now.getMinutes().toString().padStart(2,'0') + 
        now.getSeconds().toString().padStart(2,'0');
      a.download = 'extraction_' + timestamp + '.csv';
      a.click();
      URL.revokeObjectURL(url);
    }

    function showStatus(id, message, type) {
      const el = document.getElementById(id);
      el.className = 'status ' + type;
      el.textContent = message;
      el.style.whiteSpace = 'pre-wrap';
    }

    function escapeHtml(str) {
      if (!str) return '';
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    // ==================== Email Management Functions ====================

    async function deleteMatchingEmails() {
      const filter = getFilter();
      
      if (!filter.subject && !filter.sender && !filter.dateFrom && !filter.dateTo) {
        if (!confirm('âš ï¸ è­¦å‘Šï¼šæ²¡æœ‰è®¾ç½®ä»»ä½•ç­›é€‰æ¡ä»¶ï¼\n\nè¿™å°†åˆ é™¤æ–‡ä»¶å¤¹ä¸­çš„æ‰€æœ‰é‚®ä»¶ï¼\n\nç¡®å®šè¦ç»§ç»­å—ï¼Ÿ')) {
          return;
        }
      }

      const countResult = document.getElementById('countResult');
      if (!countResult.textContent.includes('æ‰¾åˆ°')) {
        alert('è¯·å…ˆç‚¹å‡»"ç»Ÿè®¡é‚®ä»¶æ•°é‡"ç¡®è®¤è¦åˆ é™¤çš„é‚®ä»¶æ•°é‡');
        return;
      }

      const match = countResult.textContent.match(/(\d+)/);
      const count = match ? parseInt(match[1]) : 0;
      
      if (count === 0) {
        alert('æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„é‚®ä»¶');
        return;
      }

      if (!confirm(`ç¡®å®šè¦åˆ é™¤ ${count} å°åŒ¹é…çš„é‚®ä»¶å—ï¼Ÿ\n\né‚®ä»¶å°†è¢«ç§»è‡³å›æ”¶ç«™ã€‚`)) {
        return;
      }

      const managementResult = document.getElementById('managementResult');
      managementResult.classList.remove('hidden');
      managementResult.className = 'status info';
      managementResult.textContent = 'æ­£åœ¨åˆ é™¤é‚®ä»¶...';

      try {
        const res = await apiPost('/api/delete', { sessionId, filter });

        const data = await res.json();

        if (data.error) {
          managementResult.className = 'status error';
          managementResult.textContent = 'âŒ åˆ é™¤å¤±è´¥: ' + data.error;
        } else {
          managementResult.className = 'status success';
          managementResult.textContent = 'âœ… ' + data.message;
          countEmails();
        }
      } catch (e) {
        managementResult.className = 'status error';
        managementResult.textContent = 'âŒ åˆ é™¤å¤±è´¥: ' + e.message;
      }
    }

    async function emptyTrash() {
      if (!confirm('âš ï¸ è­¦å‘Šï¼šè¿™å°†æ°¸ä¹…åˆ é™¤å›æ”¶ç«™ä¸­çš„æ‰€æœ‰é‚®ä»¶ï¼\n\næ­¤æ“ä½œä¸å¯æ’¤é”€ï¼\n\nç¡®å®šè¦ç»§ç»­å—ï¼Ÿ')) {
        return;
      }

      const managementResult = document.getElementById('managementResult');
      managementResult.classList.remove('hidden');
      managementResult.className = 'status info';
      managementResult.textContent = 'æ­£åœ¨æ¸…ç©ºå›æ”¶ç«™...';

      try {
        const res = await apiPost('/api/empty-trash', { sessionId });

        const data = await res.json();

        if (data.error) {
          managementResult.className = 'status error';
          managementResult.textContent = 'âŒ æ¸…ç©ºå¤±è´¥: ' + data.error;
        } else {
          managementResult.className = 'status success';
          managementResult.textContent = 'âœ… ' + data.message;
        }
      } catch (e) {
        managementResult.className = 'status error';
        managementResult.textContent = 'âŒ æ¸…ç©ºå¤±è´¥: ' + e.message;
      }
    }

    async function getTrashCount() {
      const managementResult = document.getElementById('managementResult');
      managementResult.classList.remove('hidden');
      managementResult.className = 'status info';
      managementResult.textContent = 'æ­£åœ¨æŸ¥è¯¢å›æ”¶ç«™...';

      try {
        const res = await apiPost('/api/trash-count', { sessionId });

        const data = await res.json();

        if (data.error) {
          managementResult.className = 'status error';
          managementResult.textContent = 'âŒ æŸ¥è¯¢å¤±è´¥: ' + data.error;
        } else if (data.message) {
          // Special message (e.g., no trash folder found)
          managementResult.className = 'status info';
          managementResult.textContent = `â„¹ï¸ ${data.message}`;
        } else {
          managementResult.className = 'status success';
          managementResult.textContent = `ğŸ“§ å›æ”¶ç«™ä¸­æœ‰ ${data.count} å°é‚®ä»¶`;
        }
      } catch (e) {
        managementResult.className = 'status error';
        managementResult.textContent = 'âŒ æŸ¥è¯¢å¤±è´¥: ' + e.message;
      }
    }

    // ==================== Settings Management ====================

    function saveSettings() {
      const settings = {
        email: document.getElementById('email').value,
        password: document.getElementById('password').value,
        filter: getFilter(),
        pattern: {
          name: document.getElementById('patternName').value,
          pattern: document.getElementById('pattern').value,
          flags: document.getElementById('patternFlags').value
        },
        stripHtml: document.getElementById('stripHtml').checked,
        delayMs: document.getElementById('delayMs').value
      };
      
      localStorage.setItem('extractorSettings', JSON.stringify(settings));
      alert('âœ… é…ç½®å·²ä¿å­˜åˆ°æœ¬åœ°æµè§ˆå™¨');
    }

    function loadSettings() {
      const saved = localStorage.getItem('extractorSettings');
      if (!saved) {
        alert('æ²¡æœ‰æ‰¾åˆ°ä¿å­˜çš„é…ç½®');
        return;
      }
      
      try {
        const settings = JSON.parse(saved);
        document.getElementById('email').value = settings.email || '';
        document.getElementById('password').value = settings.password || '';
        document.getElementById('folder').value = settings.filter?.folder || 'INBOX';
        document.getElementById('sender').value = settings.filter?.sender || '';
        document.getElementById('subject').value = settings.filter?.subject || '';
        document.getElementById('dateFrom').value = settings.filter?.dateFrom ? settings.filter.dateFrom.split('T')[0] : '';
        document.getElementById('dateTo').value = settings.filter?.dateTo ? settings.filter.dateTo.split('T')[0] : '';
        document.getElementById('patternName').value = settings.pattern?.name || 'default';
        document.getElementById('pattern').value = settings.pattern?.pattern || '';
        document.getElementById('patternFlags').value = settings.pattern?.flags || 'g';
        document.getElementById('stripHtml').checked = settings.stripHtml || false;
        document.getElementById('delayMs').value = settings.delayMs || 100;
        document.getElementById('delayValue').textContent = (settings.delayMs || 100) + 'ms';
        
        alert('âœ… é…ç½®å·²åŠ è½½');
      } catch (e) {
        alert('âŒ åŠ è½½é…ç½®å¤±è´¥: ' + e.message);
      }
    }

    function savePattern() {
      const pattern = {
        name: document.getElementById('patternName').value,
        pattern: document.getElementById('pattern').value,
        flags: document.getElementById('patternFlags').value,
        subject: document.getElementById('subject').value,
        savedAt: new Date().toISOString()
      };
      
      let patterns = JSON.parse(localStorage.getItem('savedPatterns') || '[]');
      patterns.push(pattern);
      localStorage.setItem('savedPatterns', JSON.stringify(patterns));
      
      alert(`âœ… æ­£åˆ™å·²ä¿å­˜ (å…± ${patterns.length} ä¸ª)`);
    }

    // ==================== Rule Editor Functions ====================
    // Requirements: 3.1, 3.3, 3.4, 4.3, 4.4, 4.5, 4.6, 4.7

    /**
     * Generate rule from target string
     * Requirements: 3.1, 3.3, 3.4 - Call /api/regex/generate with target string,
     * populate regex field with generated pattern, show pattern suggestions
     */
    async function generateRuleFromTarget() {
      const targetString = document.getElementById('targetString').value.trim();
      const statusEl = document.getElementById('ruleEditorStatus');
      
      if (!targetString) {
        showRuleEditorStatus('è¯·è¾“å…¥ç›®æ ‡å­—ç¬¦ä¸²', 'error');
        return;
      }

      // Use innerText to get plain text content (ignoring HTML tags from search highlights)
      const previewText = document.getElementById('previewResult').innerText || document.getElementById('previewResult').textContent;
      
      // Extract email content from preview (skip metadata headers)
      let emailContent = '';
      if (previewText) {
        const contentMatch = previewText.match(/===\s*å†…å®¹é•¿åº¦:.*?\n\n([\s\S]*)/);
        emailContent = contentMatch ? contentMatch[1] : previewText;
      }

      showRuleEditorStatus('æ­£åœ¨ç”Ÿæˆè§„åˆ™...', 'info');

      try {
        const res = await apiPost('/api/regex/generate', { 
          emailContent: emailContent || targetString, 
          targetString 
        });

        const data = await res.json();

        if (data.error) {
          showRuleEditorStatus('âŒ ' + data.error, 'error');
          return;
        }

        // Also generate local smart patterns based on analysis
        const localPatterns = generateLocalSmartPatterns(targetString);
        
        // Merge local patterns with API patterns, avoiding duplicates
        const allPatterns = [...localPatterns];
        if (data.patterns) {
          for (const p of data.patterns) {
            // Check if pattern already exists
            if (!allPatterns.some(lp => lp.pattern === p.pattern)) {
              allPatterns.push(p);
            }
          }
        }

        // Display pattern suggestions
        const patternsList = document.getElementById('patternsList');
        let html = '';
        
        if (allPatterns.length > 0) {
          allPatterns.forEach((p, idx) => {
            const escapedPattern = p.pattern.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
            const escapedName = (p.name || '').replace(/'/g, "\\'");
            const isLocal = p.isLocal ? 'border-color:#6001d2; background:#f8f4ff;' : '';
            const icon = p.isLocal ? 'ğŸ”§' : 'ğŸ¤–';
            html += `
              <div class="pattern-suggestion-item" style="${isLocal}" onclick="applyPatternSuggestion('${escapedPattern}', '${p.flags || 'gi'}', '${escapedName}')">
                <div class="pattern-name">${icon} ${escapeHtml(p.name || 'å»ºè®®è§„åˆ™ ' + (idx + 1))}</div>
                <code class="pattern-code">${escapeHtml(p.pattern)}</code>
                <div class="pattern-desc">${escapeHtml(p.description || '')}</div>
                <button onclick="event.stopPropagation(); applyPatternSuggestion('${escapedPattern}', '${p.flags || 'gi'}', '${escapedName}')" style="margin-top:8px; padding:5px 12px; font-size:12px; background:${p.isLocal ? '#6001d2' : '#28a745'};">âœ“ åº”ç”¨</button>
              </div>
            `;
          });
        } else {
          // If no suggestions, create a literal pattern
          const literalPattern = escapeRegexSpecialChars(targetString);
          html = `
            <div class="pattern-suggestion-item" onclick="applyPatternSuggestion('${literalPattern.replace(/'/g, "\\'")}', 'g', 'å­—é¢åŒ¹é…')">
              <div class="pattern-name">å­—é¢åŒ¹é…</div>
              <code class="pattern-code">${escapeHtml(literalPattern)}</code>
              <div class="pattern-desc">ç²¾ç¡®åŒ¹é…ç›®æ ‡å­—ç¬¦ä¸²</div>
              <button onclick="event.stopPropagation(); applyPatternSuggestion('${literalPattern.replace(/'/g, "\\'")}', 'g', 'å­—é¢åŒ¹é…')" style="margin-top:8px; padding:5px 12px; font-size:12px; background:#28a745;">âœ“ åº”ç”¨</button>
            </div>
          `;
        }

        patternsList.innerHTML = html;
        document.getElementById('generatedPatterns').classList.remove('hidden');
        
        // Auto-apply the first suggestion to the form
        if (allPatterns.length > 0) {
          const firstPattern = allPatterns[0];
          document.getElementById('pattern').value = firstPattern.pattern;
          document.getElementById('patternFlags').value = firstPattern.flags || 'gi';
          if (firstPattern.name && document.getElementById('patternName').value === 'default') {
            document.getElementById('patternName').value = firstPattern.name;
          }
          showRuleEditorStatus('âœ… å·²ç”Ÿæˆ ' + allPatterns.length + ' ä¸ªè§„åˆ™å»ºè®®', 'success');
        } else {
          showRuleEditorStatus('âœ… å·²ç”Ÿæˆå­—é¢åŒ¹é…è§„åˆ™', 'success');
        }
        
      } catch (e) {
        showRuleEditorStatus('âŒ ç”Ÿæˆè§„åˆ™å¤±è´¥: ' + e.message, 'error');
      }
    }
    
    /**
     * Generate local smart patterns based on target string analysis
     * This uses the same logic as the pattern builder modal
     */
    function generateLocalSmartPatterns(targetString) {
      const patterns = [];
      const analysis = analyzeTargetString(targetString);
      
      // Pattern 1: Full smart pattern with all detected parts
      let smartPattern = '';
      let description = '';
      
      // Add prefix if detected
      if (analysis.hasPrefix) {
        smartPattern += `(?:${escapeRegexSpecialChars(analysis.prefix)}|code|ä¼˜æƒ ç |æŠ˜æ‰£ç )[ï¼š:\\s]*`;
        description += 'å‰ç¼€åŒ¹é… + ';
      }
      
      // Start capture group
      smartPattern += '(?<code>';
      
      // Add fixed part if detected
      if (analysis.hasFixed) {
        smartPattern += escapeRegexSpecialChars(analysis.fixed);
        description += `å›ºå®šéƒ¨åˆ†(${analysis.fixed}) + `;
        
        // Add separator if detected
        if (analysis.hasSeparator) {
          smartPattern += escapeRegexSpecialChars(analysis.separator);
          description += `åˆ†éš”ç¬¦(${analysis.separator}) + `;
        }
      }
      
      // Add variable part
      if (analysis.hasVariable) {
        const varLen = analysis.variable.length;
        const minLen = Math.max(varLen - 2, 4);
        const maxLen = varLen + 4;
        
        // Check if variable part contains separators
        if (analysis.separatorCount > 0 && !analysis.hasFixed) {
          // Variable part has internal separators
          smartPattern += `[A-Z0-9${escapeRegexSpecialChars(analysis.separator)}]{${minLen},${maxLen}}`;
          description += `å˜åŠ¨éƒ¨åˆ†(å«${analysis.separator})`;
        } else {
          smartPattern += `[A-Z0-9]{${minLen},${maxLen}}`;
          description += 'å˜åŠ¨éƒ¨åˆ†';
        }
      }
      
      // Close capture group
      smartPattern += ')';
      
      if (smartPattern !== '(?<code>)') {
        patterns.push({
          pattern: smartPattern,
          flags: 'gi',
          name: analysis.hasFixed ? `${analysis.fixed} ä¼˜æƒ ç ` : 'æ™ºèƒ½åŒ¹é…è§„åˆ™',
          description: description,
          isLocal: true
        });
      }
      
      // Pattern 2: If has separators, create a pattern that matches the structure
      if (analysis.hasSeparator && analysis.variable) {
        const parts = analysis.variable.split(analysis.separator);
        if (parts.length >= 2) {
          // Create pattern matching the segment structure
          const segmentPatterns = parts.map(p => `[A-Z0-9]{${Math.max(p.length - 1, 2)},${p.length + 2}}`);
          let structuredPattern = '';
          
          if (analysis.hasPrefix) {
            structuredPattern += `(?:${escapeRegexSpecialChars(analysis.prefix)}|code|ä¼˜æƒ ç )[ï¼š:\\s]*`;
          }
          
          structuredPattern += '(?<code>';
          if (analysis.hasFixed) {
            structuredPattern += escapeRegexSpecialChars(analysis.fixed) + escapeRegexSpecialChars(analysis.separator);
          }
          structuredPattern += segmentPatterns.join(escapeRegexSpecialChars(analysis.separator));
          structuredPattern += ')';
          
          patterns.push({
            pattern: structuredPattern,
            flags: 'gi',
            name: `${parts.length}æ®µå¼ä¼˜æƒ ç `,
            description: `åŒ¹é… ${parts.length} æ®µç”¨ "${analysis.separator}" åˆ†éš”çš„ä»£ç `,
            isLocal: true
          });
        }
      }
      
      // Pattern 3: Generic code pattern with common prefixes
      const genericPattern = `(?:code|ä¼˜æƒ ç |æŠ˜æ‰£ç |å…‘æ¢ç |promo|coupon)[ï¼š:\\s]+(?<code>[A-Z0-9-_]{6,20})`;
      patterns.push({
        pattern: genericPattern,
        flags: 'gi',
        name: 'é€šç”¨ä¼˜æƒ ç ',
        description: 'åŒ¹é…å¸¸è§å‰ç¼€åçš„ä¼˜æƒ ç ',
        isLocal: true
      });
      
      return patterns;
    }

    /**
     * Apply a pattern suggestion to the rule editor form
     * Requirements: 3.4
     */
    function applyPatternSuggestion(pattern, flags, name) {
      document.getElementById('pattern').value = pattern;
      document.getElementById('patternFlags').value = flags || 'g';
      if (name && document.getElementById('patternName').value === 'default') {
        document.getElementById('patternName').value = name;
      }
      
      // å°†ç­›é€‰æ¡ä»¶ä¸­çš„ä¸»é¢˜å¡«å……åˆ°è§„åˆ™ç¼–è¾‘å™¨çš„ä¸»é¢˜æ¨¡å¼å­—æ®µ
      const subjectFilter = document.getElementById('subject').value.trim();
      const ruleSubjectPattern = document.getElementById('ruleSubjectPattern');
      if (subjectFilter && ruleSubjectPattern && !ruleSubjectPattern.value.trim()) {
        ruleSubjectPattern.value = subjectFilter;
      }
      
      showRuleEditorStatus('âœ… å·²åº”ç”¨è§„åˆ™: ' + (name || pattern.substring(0, 30)), 'success');
      
      // Scroll to the rule fields section
      document.querySelector('#ruleEditorCard .form-group').scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    /**
     * Escape special regex characters in a string
     */
    function escapeRegexSpecialChars(str) {
      return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    /**
     * Show status message in rule editor
     */
    function showRuleEditorStatus(message, type) {
      const statusEl = document.getElementById('ruleEditorStatus');
      statusEl.textContent = message;
      statusEl.style.color = type === 'error' ? '#dc3545' : type === 'success' ? '#28a745' : '#666';
      
      // Auto-clear success/info messages after 5 seconds
      if (type === 'success' || type === 'info') {
        setTimeout(() => {
          if (statusEl.textContent === message) {
            statusEl.textContent = '';
          }
        }, 5000);
      }
    }

    // Legacy function for backward compatibility
    async function generateRegex() {
      await generateRuleFromTarget();
    }

    function applyPattern(pattern, flags, name) {
      applyPatternSuggestion(pattern, flags, name);
    }

    // ==================== Pattern Builder Modal Functions ====================
    
    // Store the original target string and analyzed segments for the pattern builder
    let patternBuilderTarget = '';
    let patternBuilderSegments = [];
    let patternBuilderSeparator = '-';

    // Common fixed string patterns (brand names, campaign codes, month abbreviations, etc.)
    const COMMON_FIXED_PATTERNS = [
      // Brand/Campaign prefixes
      /^(BDAY|SMS|SMSUS|VIP|NEW|WELCOME|FIRST|SAVE|OFF|GET|FREE|DEAL|SALE|PROMO|CODE|GIFT|HOLIDAY|XMAS|CYBER|BLACK|FLASH)$/i,
      // Month abbreviations
      /^(JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)$/i,
      // Year patterns
      /^(FY\d{2,4}|20\d{2}|Q[1-4])$/i,
      // Short fixed codes (2-4 uppercase letters)
      /^[A-Z]{2,4}$/,
    ];

    /**
     * Check if a string looks like a fixed pattern
     */
    function isLikelyFixedPattern(str) {
      for (const pattern of COMMON_FIXED_PATTERNS) {
        if (pattern.test(str)) {
          return true;
        }
      }
      return false;
    }

    /**
     * Detect the character type of a string
     */
    function detectCharType(str) {
      if (/^\d+$/.test(str)) return 'numbers';
      if (/^[A-Z]+$/i.test(str)) return 'letters';
      return 'alphanumeric';
    }
    
    /**
     * Analyze target string and extract segments (new version)
     */
    function analyzeTargetString(target) {
      const result = {
        prefix: '',
        hasPrefix: false,
        separator: '',
        hasSeparator: false,
        segments: [],
        codeValue: ''
      };
      
      // Common prefix patterns
      const prefixPatterns = [
        /^(?:use\s+)?code[:\s]+/i,
        /^promo(?:\s+code)?[:\s]+/i,
        /^coupon(?:\s+code)?[:\s]+/i,
        /^discount(?:\s+code)?[:\s]+/i,
        /^(?:ä¼˜æƒ ç |æŠ˜æ‰£ç |ä»£ç |å…‘æ¢ç |éªŒè¯ç )[ï¼š:\s]+/i
      ];
      
      let codeValue = target.trim();
      
      // Check for prefix
      for (const pattern of prefixPatterns) {
        const match = codeValue.match(pattern);
        if (match) {
          result.prefix = match[0].replace(/[:\sï¼š]+$/, '');
          result.hasPrefix = true;
          codeValue = codeValue.substring(match[0].length).trim();
          break;
        }
      }
      
      result.codeValue = codeValue;
      
      // Check if code contains separator (- or _)
      if (codeValue.includes('-') || codeValue.includes('_')) {
        const dashCount = (codeValue.match(/-/g) || []).length;
        const underscoreCount = (codeValue.match(/_/g) || []).length;
        const sep = dashCount >= underscoreCount ? '-' : '_';
        result.separator = sep;
        result.hasSeparator = true;
        
        // Split into segments
        const parts = codeValue.split(sep);
        result.segments = parts.map((part, index) => {
          // First segment or common patterns are likely fixed
          const isFixed = index === 0 ? (isLikelyFixedPattern(part) || /^[A-Z]+$/i.test(part)) : isLikelyFixedPattern(part);
          
          return {
            value: part,
            length: part.length,
            isFixed: isFixed,
            type: isFixed ? 'fixed' : 'variable',
            charType: detectCharType(part)
          };
        });
      } else {
        // No separator - single segment
        result.segments = [{
          value: codeValue,
          length: codeValue.length,
          isFixed: isLikelyFixedPattern(codeValue),
          type: isLikelyFixedPattern(codeValue) ? 'fixed' : 'variable',
          charType: detectCharType(codeValue)
        }];
      }
      
      return result;
    }
    
    /**
     * Open the pattern builder modal (new version)
     */
    function openPatternBuilder() {
      const targetString = document.getElementById('targetString').value.trim();
      
      if (!targetString) {
        showRuleEditorStatus('è¯·å…ˆè¾“å…¥ç›®æ ‡å­—ç¬¦ä¸²', 'error');
        return;
      }
      
      patternBuilderTarget = targetString;
      
      // Analyze the target string
      const analysis = analyzeTargetString(targetString);
      patternBuilderSegments = analysis.segments;
      patternBuilderSeparator = analysis.separator || '';
      
      // Display analyzed parts
      const partsContent = document.getElementById('analyzedPartsContent');
      let partsHtml = `<span class="analyzed-part-tag">åŸå§‹: ${escapeHtml(targetString)}</span>`;
      
      if (analysis.hasPrefix) {
        partsHtml += `<span class="analyzed-part-tag prefix">å‰ç¼€: ${escapeHtml(analysis.prefix)}</span>`;
      }
      if (analysis.hasSeparator) {
        partsHtml += `<span class="analyzed-part-tag separator">åˆ†éš”ç¬¦: "${escapeHtml(analysis.separator)}"</span>`;
      }
      partsHtml += `<span class="analyzed-part-tag">ç æ®µæ•°: ${analysis.segments.length}</span>`;
      
      partsContent.innerHTML = partsHtml;
      
      // Pre-fill prefix
      document.getElementById('enablePrefix').checked = analysis.hasPrefix;
      document.getElementById('prefixKeywords').value = analysis.hasPrefix ? analysis.prefix : 'code|ä¼˜æƒ ç |æŠ˜æ‰£ç ';
      
      // Update separator display
      document.getElementById('detectedSeparator').textContent = analysis.separator || 'æ— ';
      document.getElementById('segmentCount').textContent = analysis.segments.length;
      
      // Generate segment UI
      generateSegmentUI(analysis.segments, analysis.separator);
      
      // Update pattern preview
      updatePatternPreview();
      
      // Show modal
      document.getElementById('patternBuilderModal').classList.add('visible');
    }
    
    /**
     * Generate UI for each code segment
     */
    function generateSegmentUI(segments, separator) {
      const container = document.getElementById('codeSegmentsContainer');
      let html = '';
      
      segments.forEach((segment, index) => {
        const typeClass = segment.isFixed ? 'segment-fixed-badge' : 'segment-variable-badge';
        const typeLabel = segment.isFixed ? 'å›ºå®š' : 'å˜åŠ¨';
        
        html += `
          <div class="code-segment" data-index="${index}">
            <div class="code-segment-header">
              <span class="segment-label">
                ç¬¬ ${index + 1} æ®µ
                <span class="segment-value">${escapeHtml(segment.value)}</span>
                <span class="${typeClass}">${typeLabel}</span>
              </span>
              <span class="segment-length-info">é•¿åº¦: ${segment.length} å­—ç¬¦</span>
            </div>
            <div class="code-segment-body">
              <select class="segment-type-select" id="segmentType_${index}" onchange="onSegmentTypeChange(${index})">
                <option value="fixed" ${segment.isFixed ? 'selected' : ''}>å›ºå®šå­—ç¬¦ä¸² (ç²¾ç¡®åŒ¹é…)</option>
                <option value="variable" ${!segment.isFixed ? 'selected' : ''}>å˜åŠ¨å­—ç¬¦ä¸² (æ¨¡å¼åŒ¹é…)</option>
              </select>
              <div id="segmentOptions_${index}" style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
                ${segment.isFixed ? `
                  <span style="color:#666; font-size:12px;">å°†ç²¾ç¡®åŒ¹é…: <code>${escapeHtml(segment.value)}</code></span>
                ` : `
                  <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; width:100%;">
                    <label style="display:flex; align-items:center; gap:5px; margin:0;">
                      <input type="checkbox" id="segmentHasPrefix_${index}" onchange="onSegmentPrefixToggle(${index})" style="width:auto;">
                      <span style="font-size:12px;">å›ºå®šå‰ç¼€:</span>
                    </label>
                    <input type="text" id="segmentPrefix_${index}" placeholder="å¦‚: VIP, NEW" style="width:80px; padding:4px; font-size:12px; display:none;" onchange="updatePatternPreview()">
                    <select id="segmentCharType_${index}" onchange="updatePatternPreview()" style="padding:4px 8px; font-size:12px;">
                      <option value="alphanumeric" ${segment.charType === 'alphanumeric' ? 'selected' : ''}>å­—æ¯+æ•°å­—</option>
                      <option value="letters" ${segment.charType === 'letters' ? 'selected' : ''}>ä»…å­—æ¯</option>
                      <option value="numbers" ${segment.charType === 'numbers' ? 'selected' : ''}>ä»…æ•°å­—</option>
                    </select>
                    <span style="font-size:12px;">é•¿åº¦:</span>
                    <input type="number" id="segmentMinLen_${index}" value="${Math.max(segment.length - 1, 1)}" min="1" max="50" style="width:50px; padding:4px; font-size:12px;" onchange="updatePatternPreview()">
                    <span>-</span>
                    <input type="number" id="segmentMaxLen_${index}" value="${segment.length + 2}" min="1" max="50" style="width:50px; padding:4px; font-size:12px;" onchange="updatePatternPreview()">
                  </div>
                `}
              </div>
            </div>
          </div>
        `;
        
        // Add separator indicator between segments
        if (index < segments.length - 1 && separator) {
          html += `<div class="segment-separator">${escapeHtml(separator)}</div>`;
        }
      });
      
      container.innerHTML = html;
    }
    
    /**
     * Handle segment type change
     */
    function onSegmentTypeChange(index) {
      const typeSelect = document.getElementById(`segmentType_${index}`);
      const optionsDiv = document.getElementById(`segmentOptions_${index}`);
      const segment = patternBuilderSegments[index];
      const isFixed = typeSelect.value === 'fixed';
      
      // Update segment data
      segment.isFixed = isFixed;
      segment.type = isFixed ? 'fixed' : 'variable';
      
      // Update badge
      const badge = document.querySelector(`.code-segment[data-index="${index}"] .segment-fixed-badge, .code-segment[data-index="${index}"] .segment-variable-badge`);
      if (badge) {
        badge.className = isFixed ? 'segment-fixed-badge' : 'segment-variable-badge';
        badge.textContent = isFixed ? 'å›ºå®š' : 'å˜åŠ¨';
      }
      
      // Update options UI
      if (isFixed) {
        optionsDiv.innerHTML = `<span style="color:#666; font-size:12px;">å°†ç²¾ç¡®åŒ¹é…: <code>${escapeHtml(segment.value)}</code></span>`;
      } else {
        optionsDiv.innerHTML = `
          <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; width:100%;">
            <label style="display:flex; align-items:center; gap:5px; margin:0;">
              <input type="checkbox" id="segmentHasPrefix_${index}" onchange="onSegmentPrefixToggle(${index})" style="width:auto;">
              <span style="font-size:12px;">å›ºå®šå‰ç¼€:</span>
            </label>
            <input type="text" id="segmentPrefix_${index}" placeholder="å¦‚: VIP, NEW" style="width:80px; padding:4px; font-size:12px; display:none;" onchange="updatePatternPreview()">
            <select id="segmentCharType_${index}" onchange="updatePatternPreview()" style="padding:4px 8px; font-size:12px;">
              <option value="alphanumeric" ${segment.charType === 'alphanumeric' ? 'selected' : ''}>å­—æ¯+æ•°å­—</option>
              <option value="letters" ${segment.charType === 'letters' ? 'selected' : ''}>ä»…å­—æ¯</option>
              <option value="numbers" ${segment.charType === 'numbers' ? 'selected' : ''}>ä»…æ•°å­—</option>
            </select>
            <span style="font-size:12px;">é•¿åº¦:</span>
            <input type="number" id="segmentMinLen_${index}" value="${Math.max(segment.length - 1, 1)}" min="1" max="50" style="width:50px; padding:4px; font-size:12px;" onchange="updatePatternPreview()">
            <span>-</span>
            <input type="number" id="segmentMaxLen_${index}" value="${segment.length + 2}" min="1" max="50" style="width:50px; padding:4px; font-size:12px;" onchange="updatePatternPreview()">
          </div>
        `;
      }
      
      updatePatternPreview();
    }
    
    /**
     * Handle segment prefix toggle
     */
    function onSegmentPrefixToggle(index) {
      const checkbox = document.getElementById(`segmentHasPrefix_${index}`);
      const prefixInput = document.getElementById(`segmentPrefix_${index}`);
      
      if (checkbox.checked) {
        prefixInput.style.display = 'block';
        // Try to auto-detect prefix from segment value
        const segment = patternBuilderSegments[index];
        const match = segment.value.match(/^([A-Z]{2,4})/i);
        if (match) {
          prefixInput.value = match[1];
        }
      } else {
        prefixInput.style.display = 'none';
        prefixInput.value = '';
      }
      
      updatePatternPreview();
    }
    
    /**
     * Close the pattern builder modal
     */
    function closePatternBuilder(event) {
      if (event && event.target !== event.currentTarget) return;
      document.getElementById('patternBuilderModal').classList.remove('visible');
    }
    
    /**
     * Add a prefix keyword to the list
     */
    function addPrefixKeyword(keyword) {
      const input = document.getElementById('prefixKeywords');
      const current = input.value.trim();
      
      if (!current) {
        input.value = keyword;
      } else {
        // Check if keyword already exists
        const keywords = current.split('|').map(k => k.trim().toLowerCase());
        if (!keywords.includes(keyword.toLowerCase())) {
          input.value = current + '|' + keyword;
        }
      }
      
      updatePatternPreview();
    }
    
    /**
     * Update the pattern preview based on current settings (new version)
     */
    function updatePatternPreview() {
      const enablePrefix = document.getElementById('enablePrefix').checked;
      
      let pattern = '';
      let displayHtml = '';
      
      // Part 1: Prefix
      if (enablePrefix) {
        const prefixKeywords = document.getElementById('prefixKeywords').value.trim();
        if (prefixKeywords) {
          const prefixPattern = `(?:${prefixKeywords})[ï¼š:\\s]*`;
          pattern += prefixPattern;
          displayHtml += `<span class="regex-prefix">(?:${escapeHtml(prefixKeywords)})[ï¼š:\\s]*</span>`;
        }
      }
      
      // Start capture group
      pattern += '(?<code>';
      displayHtml += '<span class="regex-group">(?&lt;code&gt;</span>';
      
      // Part 2: Code segments
      patternBuilderSegments.forEach((segment, index) => {
        const typeSelect = document.getElementById(`segmentType_${index}`);
        const isFixed = typeSelect ? typeSelect.value === 'fixed' : segment.isFixed;
        
        if (isFixed) {
          // Fixed segment - exact match
          const escapedValue = escapeRegexSpecialChars(segment.value);
          pattern += escapedValue;
          displayHtml += `<span class="regex-fixed">${escapeHtml(escapedValue)}</span>`;
        } else {
          // Variable segment - pattern match
          const hasPrefixCheckbox = document.getElementById(`segmentHasPrefix_${index}`);
          const prefixInput = document.getElementById(`segmentPrefix_${index}`);
          const charTypeSelect = document.getElementById(`segmentCharType_${index}`);
          const minLenInput = document.getElementById(`segmentMinLen_${index}`);
          const maxLenInput = document.getElementById(`segmentMaxLen_${index}`);
          
          // Check if segment has fixed prefix
          const hasPrefix = hasPrefixCheckbox && hasPrefixCheckbox.checked;
          const prefixValue = hasPrefix && prefixInput ? prefixInput.value.trim() : '';
          
          // Add fixed prefix if specified
          if (prefixValue) {
            const escapedPrefix = escapeRegexSpecialChars(prefixValue);
            pattern += escapedPrefix;
            displayHtml += `<span class="regex-fixed">${escapeHtml(escapedPrefix)}</span>`;
          }
          
          const charType = charTypeSelect ? charTypeSelect.value : segment.charType;
          let minLen = minLenInput ? parseInt(minLenInput.value) : Math.max(segment.length - 1, 1);
          let maxLen = maxLenInput ? parseInt(maxLenInput.value) : segment.length + 2;
          
          // Adjust length if prefix is used
          if (prefixValue) {
            const prefixLen = prefixValue.length;
            minLen = Math.max(minLen - prefixLen, 1);
            maxLen = Math.max(maxLen - prefixLen, 1);
          }
          
          let charClass = '[A-Z0-9]';
          if (charType === 'letters') charClass = '[A-Z]';
          else if (charType === 'numbers') charClass = '[0-9]';
          
          const segmentPattern = `${charClass}{${minLen},${maxLen}}`;
          pattern += segmentPattern;
          displayHtml += `<span class="regex-variable">${escapeHtml(segmentPattern)}</span>`;
        }
        
        // Add separator between segments
        if (index < patternBuilderSegments.length - 1 && patternBuilderSeparator) {
          const escapedSep = escapeRegexSpecialChars(patternBuilderSeparator);
          pattern += escapedSep;
          displayHtml += `<span class="regex-separator">${escapeHtml(escapedSep)}</span>`;
        }
      });
      
      // Close capture group
      pattern += ')';
      displayHtml += '<span class="regex-group">)</span>';
      
      // Update preview
      document.getElementById('patternPreviewBox').innerHTML = displayHtml;
      
      // Store the generated pattern for later use
      document.getElementById('patternBuilderModal').dataset.generatedPattern = pattern;
    }
    
    /**
     * Apply the built pattern to the rule editor (new version)
     */
    function applyBuiltPattern() {
      const pattern = document.getElementById('patternBuilderModal').dataset.generatedPattern;
      
      if (!pattern) {
        showRuleEditorStatus('è¯·å…ˆé…ç½®è§„åˆ™', 'error');
        return;
      }
      
      // Apply to rule editor
      document.getElementById('pattern').value = pattern;
      document.getElementById('patternFlags').value = 'gi';
      
      // Set a default name based on the first fixed segment
      const patternNameInput = document.getElementById('patternName');
      let ruleName = 'è‡ªå®šä¹‰ä¼˜æƒ ç è§„åˆ™';
      
      // Find first fixed segment for naming
      const firstFixedSegment = patternBuilderSegments.find((s, i) => {
        const typeSelect = document.getElementById(`segmentType_${i}`);
        return typeSelect ? typeSelect.value === 'fixed' : s.isFixed;
      });
      
      if (patternNameInput.value === 'default' || !patternNameInput.value) {
        if (firstFixedSegment) {
          ruleName = firstFixedSegment.value + ' ä¼˜æƒ ç ';
        }
        patternNameInput.value = ruleName;
      } else {
        ruleName = patternNameInput.value;
      }
      
      // Copy subject filter to rule subject pattern
      const subjectFilter = document.getElementById('subject').value.trim();
      const ruleSubjectPattern = document.getElementById('ruleSubjectPattern');
      if (subjectFilter && ruleSubjectPattern && !ruleSubjectPattern.value.trim()) {
        ruleSubjectPattern.value = subjectFilter;
      }
      
      // Display the generated pattern in the suggestions area
      const patternsList = document.getElementById('patternsList');
      const escapedPattern = pattern.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
      const escapedName = ruleName.replace(/'/g, "\\'");
      
      // Build description based on segments
      const fixedCount = patternBuilderSegments.filter((s, i) => {
        const typeSelect = document.getElementById(`segmentType_${i}`);
        return typeSelect ? typeSelect.value === 'fixed' : s.isFixed;
      }).length;
      const variableCount = patternBuilderSegments.length - fixedCount;
      let description = `æ™ºèƒ½ç”Ÿæˆ: ${patternBuilderSegments.length}æ®µç  (${fixedCount}å›ºå®š + ${variableCount}å˜åŠ¨)`;
      if (patternBuilderSeparator) {
        description += `, åˆ†éš”ç¬¦: "${patternBuilderSeparator}"`;
      }
      
      patternsList.innerHTML = `
        <div class="pattern-suggestion-item" style="border-color:#6001d2; background:#f8f4ff;" onclick="applyPatternSuggestion('${escapedPattern}', 'gi', '${escapedName}')">
          <div class="pattern-name" style="color:#6001d2;">ğŸ”§ ${escapeHtml(ruleName)}</div>
          <code class="pattern-code">${escapeHtml(pattern)}</code>
          <div class="pattern-desc">${escapeHtml(description)}</div>
          <button onclick="event.stopPropagation(); applyPatternSuggestion('${escapedPattern}', 'gi', '${escapedName}')" style="margin-top:8px; padding:5px 12px; font-size:12px; background:#6001d2;">âœ“ å·²åº”ç”¨</button>
        </div>
      `;
      document.getElementById('generatedPatterns').classList.remove('hidden');
      
      // Close modal
      closePatternBuilder();
      
      // Show success message
      showRuleEditorStatus('âœ… å·²åº”ç”¨æ™ºèƒ½ç”Ÿæˆçš„è§„åˆ™', 'success');
      
      // Scroll to rule fields
      document.querySelector('#ruleEditorCard .form-group').scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    /**
     * Validate regex syntax only
     * Requirements: 4.4 - IF the regex pattern is invalid THEN the System SHALL 
     * display a clear error message indicating the syntax issue
     */
    async function validateRuleSyntax() {
      const pattern = document.getElementById('pattern').value;
      const flags = document.getElementById('patternFlags').value;
      const resultEl = document.getElementById('ruleValidationResult');
      
      if (!pattern) {
        resultEl.classList.remove('hidden');
        resultEl.innerHTML = '<div class="rule-validation-error">âŒ è¯·è¾“å…¥æ­£åˆ™è¡¨è¾¾å¼</div>';
        return;
      }

      try {
        // First try local validation
        new RegExp(pattern, flags);
        
        // Call API for syntax validation (does not require email connection)
        const res = await apiPost('/api/regex/validate-syntax', { pattern, flags });
        const data = await res.json();
        
        resultEl.classList.remove('hidden');
        
        if (data.valid) {
          resultEl.innerHTML = `
            <div class="rule-validation-success">
              âœ… æ­£åˆ™è¡¨è¾¾å¼è¯­æ³•æœ‰æ•ˆ
              <br><small style="color:#666;">æ¨¡å¼: <code>${escapeHtml(pattern)}</code></small>
              <br><small style="color:#666;">æ ‡å¿—: ${flags}</small>
            </div>
          `;
          showRuleEditorStatus('âœ… è¯­æ³•éªŒè¯é€šè¿‡', 'success');
        } else {
          resultEl.innerHTML = `
            <div class="rule-validation-error">
              âŒ æ­£åˆ™è¡¨è¾¾å¼æ— æ•ˆ
              <br><small>${escapeHtml(data.error || 'è¯­æ³•é”™è¯¯')}</small>
            </div>
          `;
          showRuleEditorStatus('âŒ è¯­æ³•éªŒè¯å¤±è´¥', 'error');
        }
      } catch (e) {
        resultEl.classList.remove('hidden');
        resultEl.innerHTML = `
          <div class="rule-validation-error">
            âŒ æ­£åˆ™è¡¨è¾¾å¼æ— æ•ˆ: ${escapeHtml(e.message)}
          </div>
        `;
        showRuleEditorStatus('âŒ è¯­æ³•éªŒè¯å¤±è´¥', 'error');
      }
    }

    /**
     * Test regex against email preview content
     * Requirements: 4.3 - WHEN the user clicks "Validate Rule" THEN the System SHALL 
     * test the regex against the current email preview and display matches
     * Requirements: 4.5 - WHEN validation succeeds THEN the System SHALL highlight 
     * matched content in the email preview
     */
    async function testRuleInPreview() {
      const pattern = document.getElementById('pattern').value;
      const flags = document.getElementById('patternFlags').value;
      const resultEl = document.getElementById('ruleValidationResult');
      const previewResult = document.getElementById('previewResult');
      
      if (!pattern) {
        resultEl.classList.remove('hidden');
        resultEl.innerHTML = '<div class="rule-validation-error">âŒ è¯·è¾“å…¥æ­£åˆ™è¡¨è¾¾å¼</div>';
        return;
      }

      // Get preview content
      const previewText = previewResult.innerText || previewResult.textContent;
      if (!previewText) {
        resultEl.classList.remove('hidden');
        resultEl.innerHTML = '<div class="rule-validation-warning">âš ï¸ è¯·å…ˆé¢„è§ˆé‚®ä»¶å†…å®¹</div>';
        return;
      }

      // Extract email content from preview (skip metadata headers)
      const contentMatch = previewText.match(/===\s*å†…å®¹é•¿åº¦:.*?\n\n([\s\S]*)/);
      const emailContent = contentMatch ? contentMatch[1] : previewText;

      try {
        // Call API to test regex
        const res = await apiPost('/api/regex/test', { 
          pattern, 
          flags, 
          content: emailContent 
        });
        const data = await res.json();
        
        resultEl.classList.remove('hidden');
        
        if (data.error) {
          resultEl.innerHTML = `
            <div class="rule-validation-error">
              âŒ æµ‹è¯•å¤±è´¥: ${escapeHtml(data.error)}
            </div>
          `;
          showRuleEditorStatus('âŒ æµ‹è¯•å¤±è´¥', 'error');
          return;
        }

        const matches = data.matches || [];
        
        if (matches.length === 0) {
          resultEl.innerHTML = `
            <div class="rule-validation-warning">
              âš ï¸ æ²¡æœ‰æ‰¾åˆ°åŒ¹é…é¡¹
              <br><small style="color:#666;">è¯·æ£€æŸ¥æ­£åˆ™è¡¨è¾¾å¼æ˜¯å¦æ­£ç¡®ï¼Œæˆ–å°è¯•å…¶ä»–é‚®ä»¶</small>
            </div>
          `;
          showRuleEditorStatus('âš ï¸ æ²¡æœ‰åŒ¹é…', 'info');
        } else {
          // Display matches
          let matchesHtml = matches.slice(0, 10).map((m, i) => 
            `<span class="rule-match-highlight">${escapeHtml(typeof m === 'string' ? m : m.match || m.fullMatch || JSON.stringify(m))}</span>`
          ).join(' ');
          
          if (matches.length > 10) {
            matchesHtml += ` <small style="color:#666;">... è¿˜æœ‰ ${matches.length - 10} ä¸ªåŒ¹é…</small>`;
          }
          
          resultEl.innerHTML = `
            <div class="rule-validation-success">
              âœ… æ‰¾åˆ° ${matches.length} ä¸ªåŒ¹é…é¡¹
              <br><div style="margin-top:8px;">${matchesHtml}</div>
            </div>
          `;
          showRuleEditorStatus('âœ… æ‰¾åˆ° ' + matches.length + ' ä¸ªåŒ¹é…', 'success');
          
          // Highlight matches in preview
          highlightMatchesInPreview(emailContent, pattern, flags);
        }
      } catch (e) {
        resultEl.classList.remove('hidden');
        resultEl.innerHTML = `
          <div class="rule-validation-error">
            âŒ æµ‹è¯•å¤±è´¥: ${escapeHtml(e.message)}
          </div>
        `;
        showRuleEditorStatus('âŒ æµ‹è¯•å¤±è´¥', 'error');
      }
    }

    /**
     * Highlight regex matches in the email preview
     * Requirements: 4.5
     */
    function highlightMatchesInPreview(content, pattern, flags) {
      const previewResult = document.getElementById('previewResult');
      
      try {
        const regex = new RegExp(pattern, flags.includes('g') ? flags : flags + 'g');
        const fullPreview = previewResult.innerText || previewResult.textContent;
        
        // Find the content portion in the full preview
        const contentMatch = fullPreview.match(/===\s*å†…å®¹é•¿åº¦:.*?\n\n([\s\S]*)/);
        const headerPart = contentMatch ? fullPreview.substring(0, contentMatch.index + contentMatch[0].length - contentMatch[1].length) : '';
        const contentPart = contentMatch ? contentMatch[1] : fullPreview;
        
        // Highlight matches in content
        let highlightedContent = contentPart;
        const matches = contentPart.match(regex);
        
        if (matches && matches.length > 0) {
          // Replace matches with highlighted version (escape HTML first, then add highlights)
          highlightedContent = escapeHtml(contentPart).replace(
            new RegExp(pattern, flags.includes('g') ? flags : flags + 'g'),
            '<span class="rule-match-highlight">$&</span>'
          );
          
          // If the simple replace didn't work, try a different approach
          if (!highlightedContent.includes('rule-match-highlight')) {
            let result = '';
            let lastIndex = 0;
            const globalRegex = new RegExp(pattern, 'g' + (flags.includes('i') ? 'i' : ''));
            let match;
            
            while ((match = globalRegex.exec(contentPart)) !== null) {
              result += escapeHtml(contentPart.substring(lastIndex, match.index));
              result += `<span class="rule-match-highlight">${escapeHtml(match[0])}</span>`;
              lastIndex = match.index + match[0].length;
            }
            result += escapeHtml(contentPart.substring(lastIndex));
            highlightedContent = result;
          }
        } else {
          highlightedContent = escapeHtml(contentPart);
        }
        
        // Reconstruct the full preview with highlighted content
        previewResult.innerHTML = escapeHtml(headerPart) + highlightedContent;
        
      } catch (e) {
        console.error('Error highlighting matches:', e);
      }
    }

    /**
     * Clear the rule editor form
     */
    function clearRuleEditor() {
      document.getElementById('targetString').value = '';
      document.getElementById('patternName').value = 'default';
      document.getElementById('ruleSubjectPattern').value = '';
      document.getElementById('pattern').value = '';
      document.getElementById('patternFlags').value = 'g';
      document.getElementById('patternTags').value = '';
      
      // Clear editing mode
      editingPatternId = null;
      updateSaveButtonState();
      
      // Hide generated patterns
      document.getElementById('generatedPatterns').classList.add('hidden');
      document.getElementById('patternsList').innerHTML = '';
      
      // Hide validation results
      document.getElementById('ruleValidationResult').classList.add('hidden');
      document.getElementById('validationResult').classList.add('hidden');
      
      // Clear status
      document.getElementById('ruleEditorStatus').textContent = '';
      
      showRuleEditorStatus('å·²æ¸…ç©ºè§„åˆ™ç¼–è¾‘å™¨', 'info');
    }

    /**
     * Use current rule for extraction (populate filter form)
     */
    function useCurrentRule() {
      const pattern = document.getElementById('pattern').value;
      const subjectPattern = document.getElementById('ruleSubjectPattern').value;
      const patternName = document.getElementById('patternName').value;
      const patternFlags = document.getElementById('patternFlags').value;
      const patternTags = document.getElementById('patternTags').value;
      
      if (!pattern) {
        showRuleEditorStatus('âŒ è¯·å…ˆè¾“å…¥æ­£åˆ™è¡¨è¾¾å¼', 'error');
        return;
      }
      
      // Populate the subject filter if we have a subject pattern
      if (subjectPattern) {
        document.getElementById('subject').value = subjectPattern;
      }
      
      // Update current rule display
      updateCurrentRuleDisplay(patternName, subjectPattern, pattern, patternFlags, patternTags);
      
      showRuleEditorStatus('âœ… è§„åˆ™å·²å‡†å¤‡å°±ç»ªï¼Œå¯ä»¥å¼€å§‹æå–', 'success');
      
      // Scroll to extraction options
      document.getElementById('extractionOptionsCard').scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    /**
     * Update the current rule display in extraction options
     */
    function updateCurrentRuleDisplay(name, subject, regex, flags, tags) {
      const display = document.getElementById('currentRuleDisplay');
      document.getElementById('currentRuleName').textContent = name && name !== 'default' ? name : 'æœªå‘½åè§„åˆ™';
      document.getElementById('currentRuleSubject').textContent = subject || '(æ— ä¸»é¢˜ç­›é€‰)';
      document.getElementById('currentRuleRegex').textContent = regex;
      document.getElementById('currentRuleFlags').textContent = flags || 'g';
      
      // Display tags
      const tagsEl = document.getElementById('currentRuleTags');
      if (tags) {
        const tagList = tags.split(',').map(t => t.trim()).filter(t => t.length > 0);
        if (tagList.length > 0) {
          tagsEl.innerHTML = tagList.map(t => `<span style="background:#e3f2fd; color:#1565c0; padding:2px 6px; border-radius:10px; font-size:10px; margin-left:4px;">${escapeHtml(t)}</span>`).join('');
        } else {
          tagsEl.innerHTML = '';
        }
      } else {
        tagsEl.innerHTML = '';
      }
      
      display.classList.remove('hidden');
      
      // Enable extract button
      enableExtractButton();
    }

    /**
     * Clear the current rule display and disable extract button
     */
    function clearCurrentRule() {
      document.getElementById('currentRuleDisplay').classList.add('hidden');
      
      // Clear the pattern field as well since rule is cleared
      document.getElementById('pattern').value = '';
      document.getElementById('ruleSubjectPattern').value = '';
      document.getElementById('subject').value = '';
      
      // Disable extract button
      disableExtractButton();
    }

    /**
     * Enable the extract button
     */
    function enableExtractButton() {
      const btn = document.getElementById('extractBtn');
      const hint = document.getElementById('extractBtnHint');
      btn.disabled = false;
      btn.style.opacity = '1';
      btn.style.cursor = 'pointer';
      hint.style.display = 'none';
    }

    /**
     * Disable the extract button
     */
    function disableExtractButton() {
      const btn = document.getElementById('extractBtn');
      const hint = document.getElementById('extractBtnHint');
      btn.disabled = true;
      btn.style.opacity = '0.5';
      btn.style.cursor = 'not-allowed';
      hint.style.display = 'inline';
    }

    async function validateRegex() {
      const pattern = document.getElementById('pattern').value;
      if (!pattern) {
        alert('è¯·è¾“å…¥æˆ–ç”Ÿæˆæ­£åˆ™è¡¨è¾¾å¼');
        return;
      }

      try {
        new RegExp(pattern, document.getElementById('patternFlags').value);
      } catch (e) {
        alert('âŒ æ­£åˆ™è¡¨è¾¾å¼æ— æ•ˆ: ' + e.message);
        return;
      }

      const validationResult = document.getElementById('validationResult');
      validationResult.classList.remove('hidden');
      validationResult.innerHTML = '<p style="color:#666;">æ­£åœ¨éªŒè¯... (æœ€å¤šç­‰å¾… 60 ç§’)</p>';

      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 65000);
        
        const res = await apiRequest('/api/regex/validate', {
          method: 'POST',
          body: JSON.stringify({
            sessionId,
            filter: getFilter(),
            pattern: {
              name: document.getElementById('patternName').value,
              pattern: pattern,
              flags: document.getElementById('patternFlags').value
            },
            stripHtml: document.getElementById('stripHtml').checked,
            count: 3
          }),
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!res.ok) {
          const error = await res.json();
          validationResult.innerHTML = `<p style="color:#dc3545;">âŒ éªŒè¯å¤±è´¥: ${error.error || 'Unknown error'}</p>`;
          return;
        }

        const data = await res.json();

        if (data.error) {
          validationResult.innerHTML = `<p style="color:#dc3545;">âŒ éªŒè¯å¤±è´¥: ${data.error}</p>`;
          return;
        }

        let html = `
          <div style="margin-bottom:10px; padding:10px; background:#e8f5e9; border-radius:3px;">
            <strong style="color:#2e7d32;">âœ… éªŒè¯ç»“æœ</strong>
            <br>æµ‹è¯•é‚®ä»¶: ${data.summary.tested} å°
            <br>æˆåŠŸæå–: ${data.summary.successful} å° (${data.summary.successRate}%)
            <br>æ€»åŒ¹é…æ•°: ${data.summary.totalMatches}
            ${data.summary.timedOut ? '<br><small style="color:#ff9800;">âš ï¸ éªŒè¯åœ¨ 60 ç§’ååœæ­¢</small>' : ''}
          </div>
        `;

        data.results.forEach((r, idx) => {
          if (r.error) {
            html += `<div style="padding:8px; margin:5px 0; background:#ffebee; border-radius:3px; border-left:3px solid #dc3545;">
              <strong style="color:#dc3545;">âŒ é‚®ä»¶ ${idx + 1}: é”™è¯¯</strong>
              <br><small>${escapeHtml(r.error)}</small>
            </div>`;
          } else {
            const status = r.matchCount > 0 ? 'âœ…' : 'âŒ';
            html += `<div style="padding:8px; margin:5px 0; background:${r.matchCount > 0 ? '#e8f5e9' : '#fff3e0'}; border-radius:3px; border-left:3px solid ${r.matchCount > 0 ? '#4caf50' : '#ff9800'};">
              <strong>${status} é‚®ä»¶ ${idx + 1}: ${escapeHtml(r.subject)}</strong>
              <br><small style="color:#666;">å‘ä»¶äºº: ${escapeHtml(r.from)}</small>
              <br><small style="color:#666;">åŒ¹é…æ•°: ${r.matchCount}</small>
              ${r.matches && r.matches.length > 0 ? `<br><small style="color:#2e7d32;"><strong>æå–å†…å®¹:</strong> ${r.matches.map(m => escapeHtml(m.fullMatch)).join(', ')}</small>` : ''}
            </div>`;
          }
        });

        if (data.summary.successRate === 100) {
          html += `<div style="padding:10px; margin-top:10px; background:#d4edda; border-radius:3px; border:1px solid #c3e6cb;">
            <strong style="color:#155724;">âœ… éªŒè¯é€šè¿‡ï¼è§„åˆ™å¯ä»¥æ­£ç¡®æå–å†…å®¹</strong>
          </div>`;
        } else if (data.summary.successRate >= 50) {
          html += `<div style="padding:10px; margin-top:10px; background:#fff3cd; border-radius:3px; border:1px solid #ffeaa7;">
            <strong style="color:#856404;">âš ï¸ éƒ¨åˆ†æˆåŠŸï¼Œå»ºè®®è°ƒæ•´è§„åˆ™</strong>
          </div>`;
        } else {
          html += `<div style="padding:10px; margin-top:10px; background:#f8d7da; border-radius:3px; border:1px solid #f5c6cb;">
            <strong style="color:#721c24;">âŒ éªŒè¯å¤±è´¥ï¼Œè¯·è°ƒæ•´è§„åˆ™</strong>
          </div>`;
        }

        validationResult.innerHTML = html;
      } catch (e) {
        if (e.name === 'AbortError') {
          validationResult.innerHTML = `<p style="color:#dc3545;">âŒ éªŒè¯è¶…æ—¶ (60 ç§’)ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–å‡å°‘é‚®ä»¶æ•°é‡</p>`;
        } else {
          validationResult.innerHTML = `<p style="color:#dc3545;">âŒ éªŒè¯å‡ºé”™: ${e.message}</p>`;
        }
      }
    }
  </script>
</body>
</html>
